// <auto-generated>
//  automatically generated by the FlatBuffers compiler, do not modify
// </auto-generated>

namespace rlbot.flat
{

using global::System;
using global::System.Collections.Generic;
using global::Google.FlatBuffers;

public enum CollisionShape : byte
{
  NONE = 0,
  BoxShape = 1,
  SphereShape = 2,
  CylinderShape = 3,
};



static public class CollisionShapeVerify
{
  static public bool Verify(Google.FlatBuffers.Verifier verifier, byte typeId, uint tablePos)
  {
    bool result = true;
    switch((CollisionShape)typeId)
    {
      case CollisionShape.BoxShape:
        result = rlbot.flat.BoxShapeVerify.Verify(verifier, tablePos);
        break;
      case CollisionShape.SphereShape:
        result = rlbot.flat.SphereShapeVerify.Verify(verifier, tablePos);
        break;
      case CollisionShape.CylinderShape:
        result = rlbot.flat.CylinderShapeVerify.Verify(verifier, tablePos);
        break;
      default: result = true;
        break;
    }
    return result;
  }
}

public enum TileState : sbyte
{
  Unknown = 0,
  /// The default state of the tiles.
  Filled = 1,
  /// The state when a tile has been damaged.
  Damaged = 2,
  /// The state of a tile when it is open and a goal can be scored.
  Open = 3,
};

public enum RenderType : sbyte
{
  DrawLine2D = 1,
  DrawLine3D = 2,
  DrawLine2D_3D = 3,
  DrawRect2D = 4,
  DrawRect3D = 5,
  DrawString2D = 6,
  DrawString3D = 7,
  DrawCenteredRect3D = 8,
};

public enum QuickChatSelection : sbyte
{
  Information_IGotIt = 0,
  Information_NeedBoost = 1,
  Information_TakeTheShot = 2,
  Information_Defending = 3,
  Information_GoForIt = 4,
  Information_Centering = 5,
  Information_AllYours = 6,
  Information_InPosition = 7,
  Information_Incoming = 8,
  Compliments_NiceShot = 9,
  Compliments_GreatPass = 10,
  Compliments_Thanks = 11,
  Compliments_WhatASave = 12,
  Compliments_NiceOne = 13,
  Compliments_WhatAPlay = 14,
  Compliments_GreatClear = 15,
  Compliments_NiceBlock = 16,
  Reactions_OMG = 17,
  Reactions_Noooo = 18,
  Reactions_Wow = 19,
  Reactions_CloseOne = 20,
  Reactions_NoWay = 21,
  Reactions_HolyCow = 22,
  Reactions_Whew = 23,
  Reactions_Siiiick = 24,
  Reactions_Calculated = 25,
  Reactions_Savage = 26,
  Reactions_Okay = 27,
  Apologies_Cursing = 28,
  Apologies_NoProblem = 29,
  Apologies_Whoops = 30,
  Apologies_Sorry = 31,
  Apologies_MyBad = 32,
  Apologies_Oops = 33,
  Apologies_MyFault = 34,
  PostGame_Gg = 35,
  PostGame_WellPlayed = 36,
  PostGame_ThatWasFun = 37,
  PostGame_Rematch = 38,
  PostGame_OneMoreGame = 39,
  PostGame_WhatAGame = 40,
  PostGame_NiceMoves = 41,
  PostGame_EverybodyDance = 42,
  /// Custom text chats made by bot makers
  MaxPysonixQuickChatPresets = 43,
  /// Waste of CPU cycles
  Custom_Toxic_WasteCPU = 44,
  /// Git gud*
  Custom_Toxic_GitGut = 45,
  /// De-Allocate Yourself
  Custom_Toxic_DeAlloc = 46,
  /// 404: Your skill not found
  Custom_Toxic_404NoSkill = 47,
  /// Get a virus
  Custom_Toxic_CatchVirus = 48,
  /// Passing!
  Custom_Useful_Passing = 49,
  /// Faking!
  Custom_Useful_Faking = 50,
  /// Demoing!
  Custom_Useful_Demoing = 51,
  /// BOOPING
  Custom_Useful_Bumping = 52,
  /// The chances of that was 47525 to 1*
  Custom_Compliments_TinyChances = 53,
  /// Who upped your skill level?
  Custom_Compliments_SkillLevel = 54,
  /// Your programmer should be proud
  Custom_Compliments_proud = 55,
  /// You're the GC of Bots
  Custom_Compliments_GC = 56,
  /// Are you [Insert Pro]Bot? *
  Custom_Compliments_Pro = 57,
  /// Lag
  Custom_Excuses_Lag = 58,
  /// Ghost inputs
  Custom_Excuses_GhostInputs = 59,
  /// RIGGED
  Custom_Excuses_Rigged = 60,
  /// Mafia plays!
  Custom_Toxic_MafiaPlays = 61,
  /// Yeet!
  Custom_Exclamation_Yeet = 62,
};

public enum PlayerClass : byte
{
  NONE = 0,
  RLBotPlayer = 1,
  HumanPlayer = 2,
  PsyonixBotPlayer = 3,
  PartyMemberBotPlayer = 4,
};



static public class PlayerClassVerify
{
  static public bool Verify(Google.FlatBuffers.Verifier verifier, byte typeId, uint tablePos)
  {
    bool result = true;
    switch((PlayerClass)typeId)
    {
      case PlayerClass.RLBotPlayer:
        result = rlbot.flat.RLBotPlayerVerify.Verify(verifier, tablePos);
        break;
      case PlayerClass.HumanPlayer:
        result = rlbot.flat.HumanPlayerVerify.Verify(verifier, tablePos);
        break;
      case PlayerClass.PsyonixBotPlayer:
        result = rlbot.flat.PsyonixBotPlayerVerify.Verify(verifier, tablePos);
        break;
      case PlayerClass.PartyMemberBotPlayer:
        result = rlbot.flat.PartyMemberBotPlayerVerify.Verify(verifier, tablePos);
        break;
      default: result = true;
        break;
    }
    return result;
  }
}

public enum GameMode : sbyte
{
  Soccer = 0,
  Hoops = 1,
  Dropshot = 2,
  Hockey = 3,
  Rumble = 4,
  Heatseeker = 5,
  Gridiron = 6,
};

public enum GameMap : sbyte
{
  DFHStadium = 0,
  Mannfield = 1,
  ChampionsField = 2,
  UrbanCentral = 3,
  BeckwithPark = 4,
  UtopiaColiseum = 5,
  Wasteland = 6,
  NeoTokyo = 7,
  AquaDome = 8,
  StarbaseArc = 9,
  Farmstead = 10,
  SaltyShores = 11,
  DFHStadium_Stormy = 12,
  DFHStadium_Day = 13,
  Mannfield_Stormy = 14,
  Mannfield_Night = 15,
  ChampionsField_Day = 16,
  BeckwithPark_Stormy = 17,
  BeckwithPark_Midnight = 18,
  UrbanCentral_Night = 19,
  UrbanCentral_Dawn = 20,
  UtopiaColiseum_Dusk = 21,
  DFHStadium_Snowy = 22,
  Mannfield_Snowy = 23,
  UtopiaColiseum_Snowy = 24,
  Badlands = 25,
  Badlands_Night = 26,
  TokyoUnderpass = 27,
  Arctagon = 28,
  Pillars = 29,
  Cosmic = 30,
  DoubleGoal = 31,
  Octagon = 32,
  Underpass = 33,
  UtopiaRetro = 34,
  Hoops_DunkHouse = 35,
  DropShot_Core707 = 36,
  ThrowbackStadium = 37,
  ForbiddenTemple = 38,
  RivalsArena = 39,
  Farmstead_Night = 40,
  SaltyShores_Night = 41,
  NeonFields = 42,
  DFHStadium_Circuit = 43,
  DeadeyeCanyon = 44,
  StarbaseArc_Aftermath = 45,
  Wasteland_Night = 46,
  BeckwithPark_GothamNight = 47,
  ForbiddenTemple_Day = 48,
  UrbanCentral_Haunted = 49,
  ChampionsField_NFL = 50,
  ThrowbackStadium_Snowy = 51,
  Basin = 52,
  Corridor = 53,
  Loophole = 54,
  Galleon = 55,
  GalleonRetro = 56,
  Hourglass = 57,
  Barricade = 58,
  Colossus = 59,
};

public enum MatchLength : sbyte
{
  Five_Minutes = 0,
  Ten_Minutes = 1,
  Twenty_Minutes = 2,
  Unlimited = 3,
};

public enum MaxScore : sbyte
{
  Unlimited = 0,
  One_Goal = 1,
  Three_Goals = 2,
  Five_Goals = 3,
};

public enum OvertimeOption : sbyte
{
  Unlimited = 0,
  Five_Max_First_Score = 1,
  Five_Max_Random_Team = 2,
};

public enum SeriesLengthOption : sbyte
{
  Unlimited = 0,
  Three_Games = 1,
  Five_Games = 2,
  Seven_Games = 3,
};

public enum GameSpeedOption : sbyte
{
  Default = 0,
  Slo_Mo = 1,
  Time_Warp = 2,
};

public enum BallMaxSpeedOption : sbyte
{
  Default = 0,
  Slow = 1,
  Fast = 2,
  Super_Fast = 3,
};

public enum BallTypeOption : sbyte
{
  Default = 0,
  Cube = 1,
  Puck = 2,
  Basketball = 3,
};

public enum BallWeightOption : sbyte
{
  Default = 0,
  Light = 1,
  Heavy = 2,
  Super_Light = 3,
};

public enum BallSizeOption : sbyte
{
  Default = 0,
  Small = 1,
  Large = 2,
  Gigantic = 3,
};

public enum BallBouncinessOption : sbyte
{
  Default = 0,
  Low = 1,
  High = 2,
  Super_High = 3,
};

public enum BoostOption : sbyte
{
  Normal_Boost = 0,
  Unlimited_Boost = 1,
  Slow_Recharge = 2,
  Rapid_Recharge = 3,
  No_Boost = 4,
};

public enum RumbleOption : sbyte
{
  No_Rumble = 0,
  Default = 1,
  Slow = 2,
  Civilized = 3,
  Destruction_Derby = 4,
  Spring_Loaded = 5,
  Spikes_Only = 6,
  Spike_Rush = 7,
};

public enum BoostStrengthOption : sbyte
{
  One = 0,
  OneAndAHalf = 1,
  Two = 2,
  Ten = 3,
};

public enum GravityOption : sbyte
{
  Default = 0,
  Low = 1,
  High = 2,
  Super_High = 3,
};

public enum DemolishOption : sbyte
{
  Default = 0,
  Disabled = 1,
  Friendly_Fire = 2,
  On_Contact = 3,
  On_Contact_FF = 4,
};

public enum RespawnTimeOption : sbyte
{
  Three_Seconds = 0,
  Two_Seconds = 1,
  One_Seconds = 2,
  Disable_Goal_Reset = 3,
};

public enum ExistingMatchBehavior : sbyte
{
  /// Restart the match if any match settings differ. This is the default because old RLBot always worked this way.
  Restart_If_Different = 0,
  /// Always restart the match, even if config is identical
  Restart = 1,
  /// Never restart an existing match, just try to remove or spawn cars to match the configuration.
  /// If we are not in the middle of a match, a match will be started. Handy for LAN matches.
  Continue_And_Spawn = 2,
};

public enum GameMessage : byte
{
  NONE = 0,
  PlayerStatEvent = 1,
  PlayerSpectate = 2,
  PlayerInputChange = 3,
};



static public class GameMessageVerify
{
  static public bool Verify(Google.FlatBuffers.Verifier verifier, byte typeId, uint tablePos)
  {
    bool result = true;
    switch((GameMessage)typeId)
    {
      case GameMessage.PlayerStatEvent:
        result = rlbot.flat.PlayerStatEventVerify.Verify(verifier, tablePos);
        break;
      case GameMessage.PlayerSpectate:
        result = rlbot.flat.PlayerSpectateVerify.Verify(verifier, tablePos);
        break;
      case GameMessage.PlayerInputChange:
        result = rlbot.flat.PlayerInputChangeVerify.Verify(verifier, tablePos);
        break;
      default: result = true;
        break;
    }
    return result;
  }
}

public struct ControllerState : IFlatbufferObject
{
  private Table __p;
  public ByteBuffer ByteBuffer { get { return __p.bb; } }
  public static void ValidateVersion() { FlatBufferConstants.FLATBUFFERS_23_5_26(); }
  public static ControllerState GetRootAsControllerState(ByteBuffer _bb) { return GetRootAsControllerState(_bb, new ControllerState()); }
  public static ControllerState GetRootAsControllerState(ByteBuffer _bb, ControllerState obj) { return (obj.__assign(_bb.GetInt(_bb.Position) + _bb.Position, _bb)); }
  public void __init(int _i, ByteBuffer _bb) { __p = new Table(_i, _bb); }
  public ControllerState __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }

  /// -1 for full reverse, 1 for full forward
  public float Throttle { get { int o = __p.__offset(4); return o != 0 ? __p.bb.GetFloat(o + __p.bb_pos) : (float)0.0f; } }
  /// -1 for full left, 1 for full right
  public float Steer { get { int o = __p.__offset(6); return o != 0 ? __p.bb.GetFloat(o + __p.bb_pos) : (float)0.0f; } }
  /// -1 for nose down, 1 for nose up
  public float Pitch { get { int o = __p.__offset(8); return o != 0 ? __p.bb.GetFloat(o + __p.bb_pos) : (float)0.0f; } }
  /// -1 for full left, 1 for full right
  public float Yaw { get { int o = __p.__offset(10); return o != 0 ? __p.bb.GetFloat(o + __p.bb_pos) : (float)0.0f; } }
  /// -1 for roll left, 1 for roll right
  public float Roll { get { int o = __p.__offset(12); return o != 0 ? __p.bb.GetFloat(o + __p.bb_pos) : (float)0.0f; } }
  /// true if you want to press the jump button
  public bool Jump { get { int o = __p.__offset(14); return o != 0 ? 0!=__p.bb.Get(o + __p.bb_pos) : (bool)false; } }
  /// true if you want to press the boost button
  public bool Boost { get { int o = __p.__offset(16); return o != 0 ? 0!=__p.bb.Get(o + __p.bb_pos) : (bool)false; } }
  /// true if you want to press the handbrake button
  public bool Handbrake { get { int o = __p.__offset(18); return o != 0 ? 0!=__p.bb.Get(o + __p.bb_pos) : (bool)false; } }
  /// true if you want to press the 'use item' button, used in rumble etc.
  public bool UseItem { get { int o = __p.__offset(20); return o != 0 ? 0!=__p.bb.Get(o + __p.bb_pos) : (bool)false; } }

  public static Offset<rlbot.flat.ControllerState> CreateControllerState(FlatBufferBuilder builder,
      float throttle = 0.0f,
      float steer = 0.0f,
      float pitch = 0.0f,
      float yaw = 0.0f,
      float roll = 0.0f,
      bool jump = false,
      bool boost = false,
      bool handbrake = false,
      bool useItem = false) {
    builder.StartTable(9);
    ControllerState.AddRoll(builder, roll);
    ControllerState.AddYaw(builder, yaw);
    ControllerState.AddPitch(builder, pitch);
    ControllerState.AddSteer(builder, steer);
    ControllerState.AddThrottle(builder, throttle);
    ControllerState.AddUseItem(builder, useItem);
    ControllerState.AddHandbrake(builder, handbrake);
    ControllerState.AddBoost(builder, boost);
    ControllerState.AddJump(builder, jump);
    return ControllerState.EndControllerState(builder);
  }

  public static void StartControllerState(FlatBufferBuilder builder) { builder.StartTable(9); }
  public static void AddThrottle(FlatBufferBuilder builder, float throttle) { builder.AddFloat(0, throttle, 0.0f); }
  public static void AddSteer(FlatBufferBuilder builder, float steer) { builder.AddFloat(1, steer, 0.0f); }
  public static void AddPitch(FlatBufferBuilder builder, float pitch) { builder.AddFloat(2, pitch, 0.0f); }
  public static void AddYaw(FlatBufferBuilder builder, float yaw) { builder.AddFloat(3, yaw, 0.0f); }
  public static void AddRoll(FlatBufferBuilder builder, float roll) { builder.AddFloat(4, roll, 0.0f); }
  public static void AddJump(FlatBufferBuilder builder, bool jump) { builder.AddBool(5, jump, false); }
  public static void AddBoost(FlatBufferBuilder builder, bool boost) { builder.AddBool(6, boost, false); }
  public static void AddHandbrake(FlatBufferBuilder builder, bool handbrake) { builder.AddBool(7, handbrake, false); }
  public static void AddUseItem(FlatBufferBuilder builder, bool useItem) { builder.AddBool(8, useItem, false); }
  public static Offset<rlbot.flat.ControllerState> EndControllerState(FlatBufferBuilder builder) {
    int o = builder.EndTable();
    return new Offset<rlbot.flat.ControllerState>(o);
  }
}


static public class ControllerStateVerify
{
  static public bool Verify(Google.FlatBuffers.Verifier verifier, uint tablePos)
  {
    return verifier.VerifyTableStart(tablePos)
      && verifier.VerifyField(tablePos, 4 /*Throttle*/, 4 /*float*/, 4, false)
      && verifier.VerifyField(tablePos, 6 /*Steer*/, 4 /*float*/, 4, false)
      && verifier.VerifyField(tablePos, 8 /*Pitch*/, 4 /*float*/, 4, false)
      && verifier.VerifyField(tablePos, 10 /*Yaw*/, 4 /*float*/, 4, false)
      && verifier.VerifyField(tablePos, 12 /*Roll*/, 4 /*float*/, 4, false)
      && verifier.VerifyField(tablePos, 14 /*Jump*/, 1 /*bool*/, 1, false)
      && verifier.VerifyField(tablePos, 16 /*Boost*/, 1 /*bool*/, 1, false)
      && verifier.VerifyField(tablePos, 18 /*Handbrake*/, 1 /*bool*/, 1, false)
      && verifier.VerifyField(tablePos, 20 /*UseItem*/, 1 /*bool*/, 1, false)
      && verifier.VerifyTableEnd(tablePos);
  }
}
public struct PlayerInput : IFlatbufferObject
{
  private Table __p;
  public ByteBuffer ByteBuffer { get { return __p.bb; } }
  public static void ValidateVersion() { FlatBufferConstants.FLATBUFFERS_23_5_26(); }
  public static PlayerInput GetRootAsPlayerInput(ByteBuffer _bb) { return GetRootAsPlayerInput(_bb, new PlayerInput()); }
  public static PlayerInput GetRootAsPlayerInput(ByteBuffer _bb, PlayerInput obj) { return (obj.__assign(_bb.GetInt(_bb.Position) + _bb.Position, _bb)); }
  public void __init(int _i, ByteBuffer _bb) { __p = new Table(_i, _bb); }
  public PlayerInput __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }

  public int PlayerIndex { get { int o = __p.__offset(4); return o != 0 ? __p.bb.GetInt(o + __p.bb_pos) : (int)0; } }
  public rlbot.flat.ControllerState? ControllerState { get { int o = __p.__offset(6); return o != 0 ? (rlbot.flat.ControllerState?)(new rlbot.flat.ControllerState()).__assign(__p.__indirect(o + __p.bb_pos), __p.bb) : null; } }

  public static Offset<rlbot.flat.PlayerInput> CreatePlayerInput(FlatBufferBuilder builder,
      int playerIndex = 0,
      Offset<rlbot.flat.ControllerState> controllerStateOffset = default(Offset<rlbot.flat.ControllerState>)) {
    builder.StartTable(2);
    PlayerInput.AddControllerState(builder, controllerStateOffset);
    PlayerInput.AddPlayerIndex(builder, playerIndex);
    return PlayerInput.EndPlayerInput(builder);
  }

  public static void StartPlayerInput(FlatBufferBuilder builder) { builder.StartTable(2); }
  public static void AddPlayerIndex(FlatBufferBuilder builder, int playerIndex) { builder.AddInt(0, playerIndex, 0); }
  public static void AddControllerState(FlatBufferBuilder builder, Offset<rlbot.flat.ControllerState> controllerStateOffset) { builder.AddOffset(1, controllerStateOffset.Value, 0); }
  public static Offset<rlbot.flat.PlayerInput> EndPlayerInput(FlatBufferBuilder builder) {
    int o = builder.EndTable();
    return new Offset<rlbot.flat.PlayerInput>(o);
  }
}


static public class PlayerInputVerify
{
  static public bool Verify(Google.FlatBuffers.Verifier verifier, uint tablePos)
  {
    return verifier.VerifyTableStart(tablePos)
      && verifier.VerifyField(tablePos, 4 /*PlayerIndex*/, 4 /*int*/, 4, false)
      && verifier.VerifyTable(tablePos, 6 /*ControllerState*/, rlbot.flat.ControllerStateVerify.Verify, false)
      && verifier.VerifyTableEnd(tablePos);
  }
}
public struct Vector3 : IFlatbufferObject
{
  private Struct __p;
  public ByteBuffer ByteBuffer { get { return __p.bb; } }
  public void __init(int _i, ByteBuffer _bb) { __p = new Struct(_i, _bb); }
  public Vector3 __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }

  public float X { get { return __p.bb.GetFloat(__p.bb_pos + 0); } }
  public float Y { get { return __p.bb.GetFloat(__p.bb_pos + 4); } }
  public float Z { get { return __p.bb.GetFloat(__p.bb_pos + 8); } }

  public static Offset<rlbot.flat.Vector3> CreateVector3(FlatBufferBuilder builder, float X, float Y, float Z) {
    builder.Prep(4, 12);
    builder.PutFloat(Z);
    builder.PutFloat(Y);
    builder.PutFloat(X);
    return new Offset<rlbot.flat.Vector3>(builder.Offset);
  }
}

/// Expresses the rotation state of an object in Euler angles, with values in radians.
public struct Rotator : IFlatbufferObject
{
  private Struct __p;
  public ByteBuffer ByteBuffer { get { return __p.bb; } }
  public void __init(int _i, ByteBuffer _bb) { __p = new Struct(_i, _bb); }
  public Rotator __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }

  public float Pitch { get { return __p.bb.GetFloat(__p.bb_pos + 0); } }
  public float Yaw { get { return __p.bb.GetFloat(__p.bb_pos + 4); } }
  public float Roll { get { return __p.bb.GetFloat(__p.bb_pos + 8); } }

  public static Offset<rlbot.flat.Rotator> CreateRotator(FlatBufferBuilder builder, float Pitch, float Yaw, float Roll) {
    builder.Prep(4, 12);
    builder.PutFloat(Roll);
    builder.PutFloat(Yaw);
    builder.PutFloat(Pitch);
    return new Offset<rlbot.flat.Rotator>(builder.Offset);
  }
}

/// Expresses the rotation state of an object.
/// Learn about quaternions here: https://en.wikipedia.org/wiki/Quaternions_and_spatial_rotation
/// You can tinker with them here to build an intuition: https://quaternions.online/
public struct Quaternion : IFlatbufferObject
{
  private Struct __p;
  public ByteBuffer ByteBuffer { get { return __p.bb; } }
  public void __init(int _i, ByteBuffer _bb) { __p = new Struct(_i, _bb); }
  public Quaternion __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }

  public float X { get { return __p.bb.GetFloat(__p.bb_pos + 0); } }
  public float Y { get { return __p.bb.GetFloat(__p.bb_pos + 4); } }
  public float Z { get { return __p.bb.GetFloat(__p.bb_pos + 8); } }
  public float W { get { return __p.bb.GetFloat(__p.bb_pos + 12); } }

  public static Offset<rlbot.flat.Quaternion> CreateQuaternion(FlatBufferBuilder builder, float X, float Y, float Z, float W) {
    builder.Prep(4, 16);
    builder.PutFloat(W);
    builder.PutFloat(Z);
    builder.PutFloat(Y);
    builder.PutFloat(X);
    return new Offset<rlbot.flat.Quaternion>(builder.Offset);
  }
}

public struct BoxShape : IFlatbufferObject
{
  private Table __p;
  public ByteBuffer ByteBuffer { get { return __p.bb; } }
  public static void ValidateVersion() { FlatBufferConstants.FLATBUFFERS_23_5_26(); }
  public static BoxShape GetRootAsBoxShape(ByteBuffer _bb) { return GetRootAsBoxShape(_bb, new BoxShape()); }
  public static BoxShape GetRootAsBoxShape(ByteBuffer _bb, BoxShape obj) { return (obj.__assign(_bb.GetInt(_bb.Position) + _bb.Position, _bb)); }
  public void __init(int _i, ByteBuffer _bb) { __p = new Table(_i, _bb); }
  public BoxShape __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }

  public float Length { get { int o = __p.__offset(4); return o != 0 ? __p.bb.GetFloat(o + __p.bb_pos) : (float)0.0f; } }
  public float Width { get { int o = __p.__offset(6); return o != 0 ? __p.bb.GetFloat(o + __p.bb_pos) : (float)0.0f; } }
  public float Height { get { int o = __p.__offset(8); return o != 0 ? __p.bb.GetFloat(o + __p.bb_pos) : (float)0.0f; } }

  public static Offset<rlbot.flat.BoxShape> CreateBoxShape(FlatBufferBuilder builder,
      float length = 0.0f,
      float width = 0.0f,
      float height = 0.0f) {
    builder.StartTable(3);
    BoxShape.AddHeight(builder, height);
    BoxShape.AddWidth(builder, width);
    BoxShape.AddLength(builder, length);
    return BoxShape.EndBoxShape(builder);
  }

  public static void StartBoxShape(FlatBufferBuilder builder) { builder.StartTable(3); }
  public static void AddLength(FlatBufferBuilder builder, float length) { builder.AddFloat(0, length, 0.0f); }
  public static void AddWidth(FlatBufferBuilder builder, float width) { builder.AddFloat(1, width, 0.0f); }
  public static void AddHeight(FlatBufferBuilder builder, float height) { builder.AddFloat(2, height, 0.0f); }
  public static Offset<rlbot.flat.BoxShape> EndBoxShape(FlatBufferBuilder builder) {
    int o = builder.EndTable();
    return new Offset<rlbot.flat.BoxShape>(o);
  }
}


static public class BoxShapeVerify
{
  static public bool Verify(Google.FlatBuffers.Verifier verifier, uint tablePos)
  {
    return verifier.VerifyTableStart(tablePos)
      && verifier.VerifyField(tablePos, 4 /*Length*/, 4 /*float*/, 4, false)
      && verifier.VerifyField(tablePos, 6 /*Width*/, 4 /*float*/, 4, false)
      && verifier.VerifyField(tablePos, 8 /*Height*/, 4 /*float*/, 4, false)
      && verifier.VerifyTableEnd(tablePos);
  }
}
public struct SphereShape : IFlatbufferObject
{
  private Table __p;
  public ByteBuffer ByteBuffer { get { return __p.bb; } }
  public static void ValidateVersion() { FlatBufferConstants.FLATBUFFERS_23_5_26(); }
  public static SphereShape GetRootAsSphereShape(ByteBuffer _bb) { return GetRootAsSphereShape(_bb, new SphereShape()); }
  public static SphereShape GetRootAsSphereShape(ByteBuffer _bb, SphereShape obj) { return (obj.__assign(_bb.GetInt(_bb.Position) + _bb.Position, _bb)); }
  public void __init(int _i, ByteBuffer _bb) { __p = new Table(_i, _bb); }
  public SphereShape __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }

  public float Diameter { get { int o = __p.__offset(4); return o != 0 ? __p.bb.GetFloat(o + __p.bb_pos) : (float)0.0f; } }

  public static Offset<rlbot.flat.SphereShape> CreateSphereShape(FlatBufferBuilder builder,
      float diameter = 0.0f) {
    builder.StartTable(1);
    SphereShape.AddDiameter(builder, diameter);
    return SphereShape.EndSphereShape(builder);
  }

  public static void StartSphereShape(FlatBufferBuilder builder) { builder.StartTable(1); }
  public static void AddDiameter(FlatBufferBuilder builder, float diameter) { builder.AddFloat(0, diameter, 0.0f); }
  public static Offset<rlbot.flat.SphereShape> EndSphereShape(FlatBufferBuilder builder) {
    int o = builder.EndTable();
    return new Offset<rlbot.flat.SphereShape>(o);
  }
}


static public class SphereShapeVerify
{
  static public bool Verify(Google.FlatBuffers.Verifier verifier, uint tablePos)
  {
    return verifier.VerifyTableStart(tablePos)
      && verifier.VerifyField(tablePos, 4 /*Diameter*/, 4 /*float*/, 4, false)
      && verifier.VerifyTableEnd(tablePos);
  }
}
public struct CylinderShape : IFlatbufferObject
{
  private Table __p;
  public ByteBuffer ByteBuffer { get { return __p.bb; } }
  public static void ValidateVersion() { FlatBufferConstants.FLATBUFFERS_23_5_26(); }
  public static CylinderShape GetRootAsCylinderShape(ByteBuffer _bb) { return GetRootAsCylinderShape(_bb, new CylinderShape()); }
  public static CylinderShape GetRootAsCylinderShape(ByteBuffer _bb, CylinderShape obj) { return (obj.__assign(_bb.GetInt(_bb.Position) + _bb.Position, _bb)); }
  public void __init(int _i, ByteBuffer _bb) { __p = new Table(_i, _bb); }
  public CylinderShape __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }

  public float Diameter { get { int o = __p.__offset(4); return o != 0 ? __p.bb.GetFloat(o + __p.bb_pos) : (float)0.0f; } }
  public float Height { get { int o = __p.__offset(6); return o != 0 ? __p.bb.GetFloat(o + __p.bb_pos) : (float)0.0f; } }

  public static Offset<rlbot.flat.CylinderShape> CreateCylinderShape(FlatBufferBuilder builder,
      float diameter = 0.0f,
      float height = 0.0f) {
    builder.StartTable(2);
    CylinderShape.AddHeight(builder, height);
    CylinderShape.AddDiameter(builder, diameter);
    return CylinderShape.EndCylinderShape(builder);
  }

  public static void StartCylinderShape(FlatBufferBuilder builder) { builder.StartTable(2); }
  public static void AddDiameter(FlatBufferBuilder builder, float diameter) { builder.AddFloat(0, diameter, 0.0f); }
  public static void AddHeight(FlatBufferBuilder builder, float height) { builder.AddFloat(1, height, 0.0f); }
  public static Offset<rlbot.flat.CylinderShape> EndCylinderShape(FlatBufferBuilder builder) {
    int o = builder.EndTable();
    return new Offset<rlbot.flat.CylinderShape>(o);
  }
}


static public class CylinderShapeVerify
{
  static public bool Verify(Google.FlatBuffers.Verifier verifier, uint tablePos)
  {
    return verifier.VerifyTableStart(tablePos)
      && verifier.VerifyField(tablePos, 4 /*Diameter*/, 4 /*float*/, 4, false)
      && verifier.VerifyField(tablePos, 6 /*Height*/, 4 /*float*/, 4, false)
      && verifier.VerifyTableEnd(tablePos);
  }
}
public struct Touch : IFlatbufferObject
{
  private Table __p;
  public ByteBuffer ByteBuffer { get { return __p.bb; } }
  public static void ValidateVersion() { FlatBufferConstants.FLATBUFFERS_23_5_26(); }
  public static Touch GetRootAsTouch(ByteBuffer _bb) { return GetRootAsTouch(_bb, new Touch()); }
  public static Touch GetRootAsTouch(ByteBuffer _bb, Touch obj) { return (obj.__assign(_bb.GetInt(_bb.Position) + _bb.Position, _bb)); }
  public void __init(int _i, ByteBuffer _bb) { __p = new Table(_i, _bb); }
  public Touch __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }

  /// The name of the player involved with the touch.
  public string PlayerName { get { int o = __p.__offset(4); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetPlayerNameBytes() { return __p.__vector_as_span<byte>(4, 1); }
#else
  public ArraySegment<byte>? GetPlayerNameBytes() { return __p.__vector_as_arraysegment(4); }
#endif
  public byte[] GetPlayerNameArray() { return __p.__vector_as_array<byte>(4); }
  /// Seconds that had elapsed in the game when the touch occurred.
  public float GameSeconds { get { int o = __p.__offset(6); return o != 0 ? __p.bb.GetFloat(o + __p.bb_pos) : (float)0.0f; } }
  /// The point of contact for the touch.
  public rlbot.flat.Vector3? Location { get { int o = __p.__offset(8); return o != 0 ? (rlbot.flat.Vector3?)(new rlbot.flat.Vector3()).__assign(o + __p.bb_pos, __p.bb) : null; } }
  /// The direction of the touch.
  public rlbot.flat.Vector3? Normal { get { int o = __p.__offset(10); return o != 0 ? (rlbot.flat.Vector3?)(new rlbot.flat.Vector3()).__assign(o + __p.bb_pos, __p.bb) : null; } }
  /// The Team which the touch belongs to, 0 for blue 1 for orange.
  public int Team { get { int o = __p.__offset(12); return o != 0 ? __p.bb.GetInt(o + __p.bb_pos) : (int)0; } }
  /// The index of the player involved with the touch.
  public int PlayerIndex { get { int o = __p.__offset(14); return o != 0 ? __p.bb.GetInt(o + __p.bb_pos) : (int)0; } }

  public static void StartTouch(FlatBufferBuilder builder) { builder.StartTable(6); }
  public static void AddPlayerName(FlatBufferBuilder builder, StringOffset playerNameOffset) { builder.AddOffset(0, playerNameOffset.Value, 0); }
  public static void AddGameSeconds(FlatBufferBuilder builder, float gameSeconds) { builder.AddFloat(1, gameSeconds, 0.0f); }
  public static void AddLocation(FlatBufferBuilder builder, Offset<rlbot.flat.Vector3> locationOffset) { builder.AddStruct(2, locationOffset.Value, 0); }
  public static void AddNormal(FlatBufferBuilder builder, Offset<rlbot.flat.Vector3> normalOffset) { builder.AddStruct(3, normalOffset.Value, 0); }
  public static void AddTeam(FlatBufferBuilder builder, int team) { builder.AddInt(4, team, 0); }
  public static void AddPlayerIndex(FlatBufferBuilder builder, int playerIndex) { builder.AddInt(5, playerIndex, 0); }
  public static Offset<rlbot.flat.Touch> EndTouch(FlatBufferBuilder builder) {
    int o = builder.EndTable();
    return new Offset<rlbot.flat.Touch>(o);
  }
}


static public class TouchVerify
{
  static public bool Verify(Google.FlatBuffers.Verifier verifier, uint tablePos)
  {
    return verifier.VerifyTableStart(tablePos)
      && verifier.VerifyString(tablePos, 4 /*PlayerName*/, false)
      && verifier.VerifyField(tablePos, 6 /*GameSeconds*/, 4 /*float*/, 4, false)
      && verifier.VerifyField(tablePos, 8 /*Location*/, 12 /*rlbot.flat.Vector3*/, 4, false)
      && verifier.VerifyField(tablePos, 10 /*Normal*/, 12 /*rlbot.flat.Vector3*/, 4, false)
      && verifier.VerifyField(tablePos, 12 /*Team*/, 4 /*int*/, 4, false)
      && verifier.VerifyField(tablePos, 14 /*PlayerIndex*/, 4 /*int*/, 4, false)
      && verifier.VerifyTableEnd(tablePos);
  }
}
public struct ScoreInfo : IFlatbufferObject
{
  private Table __p;
  public ByteBuffer ByteBuffer { get { return __p.bb; } }
  public static void ValidateVersion() { FlatBufferConstants.FLATBUFFERS_23_5_26(); }
  public static ScoreInfo GetRootAsScoreInfo(ByteBuffer _bb) { return GetRootAsScoreInfo(_bb, new ScoreInfo()); }
  public static ScoreInfo GetRootAsScoreInfo(ByteBuffer _bb, ScoreInfo obj) { return (obj.__assign(_bb.GetInt(_bb.Position) + _bb.Position, _bb)); }
  public void __init(int _i, ByteBuffer _bb) { __p = new Table(_i, _bb); }
  public ScoreInfo __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }

  public int Score { get { int o = __p.__offset(4); return o != 0 ? __p.bb.GetInt(o + __p.bb_pos) : (int)0; } }
  public int Goals { get { int o = __p.__offset(6); return o != 0 ? __p.bb.GetInt(o + __p.bb_pos) : (int)0; } }
  public int OwnGoals { get { int o = __p.__offset(8); return o != 0 ? __p.bb.GetInt(o + __p.bb_pos) : (int)0; } }
  public int Assists { get { int o = __p.__offset(10); return o != 0 ? __p.bb.GetInt(o + __p.bb_pos) : (int)0; } }
  public int Saves { get { int o = __p.__offset(12); return o != 0 ? __p.bb.GetInt(o + __p.bb_pos) : (int)0; } }
  public int Shots { get { int o = __p.__offset(14); return o != 0 ? __p.bb.GetInt(o + __p.bb_pos) : (int)0; } }
  public int Demolitions { get { int o = __p.__offset(16); return o != 0 ? __p.bb.GetInt(o + __p.bb_pos) : (int)0; } }

  public static Offset<rlbot.flat.ScoreInfo> CreateScoreInfo(FlatBufferBuilder builder,
      int score = 0,
      int goals = 0,
      int ownGoals = 0,
      int assists = 0,
      int saves = 0,
      int shots = 0,
      int demolitions = 0) {
    builder.StartTable(7);
    ScoreInfo.AddDemolitions(builder, demolitions);
    ScoreInfo.AddShots(builder, shots);
    ScoreInfo.AddSaves(builder, saves);
    ScoreInfo.AddAssists(builder, assists);
    ScoreInfo.AddOwnGoals(builder, ownGoals);
    ScoreInfo.AddGoals(builder, goals);
    ScoreInfo.AddScore(builder, score);
    return ScoreInfo.EndScoreInfo(builder);
  }

  public static void StartScoreInfo(FlatBufferBuilder builder) { builder.StartTable(7); }
  public static void AddScore(FlatBufferBuilder builder, int score) { builder.AddInt(0, score, 0); }
  public static void AddGoals(FlatBufferBuilder builder, int goals) { builder.AddInt(1, goals, 0); }
  public static void AddOwnGoals(FlatBufferBuilder builder, int ownGoals) { builder.AddInt(2, ownGoals, 0); }
  public static void AddAssists(FlatBufferBuilder builder, int assists) { builder.AddInt(3, assists, 0); }
  public static void AddSaves(FlatBufferBuilder builder, int saves) { builder.AddInt(4, saves, 0); }
  public static void AddShots(FlatBufferBuilder builder, int shots) { builder.AddInt(5, shots, 0); }
  public static void AddDemolitions(FlatBufferBuilder builder, int demolitions) { builder.AddInt(6, demolitions, 0); }
  public static Offset<rlbot.flat.ScoreInfo> EndScoreInfo(FlatBufferBuilder builder) {
    int o = builder.EndTable();
    return new Offset<rlbot.flat.ScoreInfo>(o);
  }
}


static public class ScoreInfoVerify
{
  static public bool Verify(Google.FlatBuffers.Verifier verifier, uint tablePos)
  {
    return verifier.VerifyTableStart(tablePos)
      && verifier.VerifyField(tablePos, 4 /*Score*/, 4 /*int*/, 4, false)
      && verifier.VerifyField(tablePos, 6 /*Goals*/, 4 /*int*/, 4, false)
      && verifier.VerifyField(tablePos, 8 /*OwnGoals*/, 4 /*int*/, 4, false)
      && verifier.VerifyField(tablePos, 10 /*Assists*/, 4 /*int*/, 4, false)
      && verifier.VerifyField(tablePos, 12 /*Saves*/, 4 /*int*/, 4, false)
      && verifier.VerifyField(tablePos, 14 /*Shots*/, 4 /*int*/, 4, false)
      && verifier.VerifyField(tablePos, 16 /*Demolitions*/, 4 /*int*/, 4, false)
      && verifier.VerifyTableEnd(tablePos);
  }
}
public struct Physics : IFlatbufferObject
{
  private Table __p;
  public ByteBuffer ByteBuffer { get { return __p.bb; } }
  public static void ValidateVersion() { FlatBufferConstants.FLATBUFFERS_23_5_26(); }
  public static Physics GetRootAsPhysics(ByteBuffer _bb) { return GetRootAsPhysics(_bb, new Physics()); }
  public static Physics GetRootAsPhysics(ByteBuffer _bb, Physics obj) { return (obj.__assign(_bb.GetInt(_bb.Position) + _bb.Position, _bb)); }
  public void __init(int _i, ByteBuffer _bb) { __p = new Table(_i, _bb); }
  public Physics __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }

  public rlbot.flat.Vector3? Location { get { int o = __p.__offset(4); return o != 0 ? (rlbot.flat.Vector3?)(new rlbot.flat.Vector3()).__assign(o + __p.bb_pos, __p.bb) : null; } }
  public rlbot.flat.Rotator? Rotation { get { int o = __p.__offset(6); return o != 0 ? (rlbot.flat.Rotator?)(new rlbot.flat.Rotator()).__assign(o + __p.bb_pos, __p.bb) : null; } }
  public rlbot.flat.Vector3? Velocity { get { int o = __p.__offset(8); return o != 0 ? (rlbot.flat.Vector3?)(new rlbot.flat.Vector3()).__assign(o + __p.bb_pos, __p.bb) : null; } }
  public rlbot.flat.Vector3? AngularVelocity { get { int o = __p.__offset(10); return o != 0 ? (rlbot.flat.Vector3?)(new rlbot.flat.Vector3()).__assign(o + __p.bb_pos, __p.bb) : null; } }

  public static void StartPhysics(FlatBufferBuilder builder) { builder.StartTable(4); }
  public static void AddLocation(FlatBufferBuilder builder, Offset<rlbot.flat.Vector3> locationOffset) { builder.AddStruct(0, locationOffset.Value, 0); }
  public static void AddRotation(FlatBufferBuilder builder, Offset<rlbot.flat.Rotator> rotationOffset) { builder.AddStruct(1, rotationOffset.Value, 0); }
  public static void AddVelocity(FlatBufferBuilder builder, Offset<rlbot.flat.Vector3> velocityOffset) { builder.AddStruct(2, velocityOffset.Value, 0); }
  public static void AddAngularVelocity(FlatBufferBuilder builder, Offset<rlbot.flat.Vector3> angularVelocityOffset) { builder.AddStruct(3, angularVelocityOffset.Value, 0); }
  public static Offset<rlbot.flat.Physics> EndPhysics(FlatBufferBuilder builder) {
    int o = builder.EndTable();
    return new Offset<rlbot.flat.Physics>(o);
  }
}


static public class PhysicsVerify
{
  static public bool Verify(Google.FlatBuffers.Verifier verifier, uint tablePos)
  {
    return verifier.VerifyTableStart(tablePos)
      && verifier.VerifyField(tablePos, 4 /*Location*/, 12 /*rlbot.flat.Vector3*/, 4, false)
      && verifier.VerifyField(tablePos, 6 /*Rotation*/, 12 /*rlbot.flat.Rotator*/, 4, false)
      && verifier.VerifyField(tablePos, 8 /*Velocity*/, 12 /*rlbot.flat.Vector3*/, 4, false)
      && verifier.VerifyField(tablePos, 10 /*AngularVelocity*/, 12 /*rlbot.flat.Vector3*/, 4, false)
      && verifier.VerifyTableEnd(tablePos);
  }
}
public struct PlayerInfo : IFlatbufferObject
{
  private Table __p;
  public ByteBuffer ByteBuffer { get { return __p.bb; } }
  public static void ValidateVersion() { FlatBufferConstants.FLATBUFFERS_23_5_26(); }
  public static PlayerInfo GetRootAsPlayerInfo(ByteBuffer _bb) { return GetRootAsPlayerInfo(_bb, new PlayerInfo()); }
  public static PlayerInfo GetRootAsPlayerInfo(ByteBuffer _bb, PlayerInfo obj) { return (obj.__assign(_bb.GetInt(_bb.Position) + _bb.Position, _bb)); }
  public void __init(int _i, ByteBuffer _bb) { __p = new Table(_i, _bb); }
  public PlayerInfo __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }

  public rlbot.flat.Physics? Physics { get { int o = __p.__offset(4); return o != 0 ? (rlbot.flat.Physics?)(new rlbot.flat.Physics()).__assign(__p.__indirect(o + __p.bb_pos), __p.bb) : null; } }
  public rlbot.flat.ScoreInfo? ScoreInfo { get { int o = __p.__offset(6); return o != 0 ? (rlbot.flat.ScoreInfo?)(new rlbot.flat.ScoreInfo()).__assign(__p.__indirect(o + __p.bb_pos), __p.bb) : null; } }
  public bool IsDemolished { get { int o = __p.__offset(8); return o != 0 ? 0!=__p.bb.Get(o + __p.bb_pos) : (bool)false; } }
  /// True if your wheels are on the ground, the wall, or the ceiling. False if you're midair or turtling.
  public bool HasWheelContact { get { int o = __p.__offset(10); return o != 0 ? 0!=__p.bb.Get(o + __p.bb_pos) : (bool)false; } }
  public bool IsSupersonic { get { int o = __p.__offset(12); return o != 0 ? 0!=__p.bb.Get(o + __p.bb_pos) : (bool)false; } }
  public bool IsBot { get { int o = __p.__offset(14); return o != 0 ? 0!=__p.bb.Get(o + __p.bb_pos) : (bool)false; } }
  /// True if the player has jumped. Falling off the ceiling / driving off the goal post does not count.
  public bool Jumped { get { int o = __p.__offset(16); return o != 0 ? 0!=__p.bb.Get(o + __p.bb_pos) : (bool)false; } }
  ///  True if player has double jumped. False does not mean you have a jump remaining, because the
  ///  aerial timer can run out, and that doesn't affect this flag.
  public bool DoubleJumped { get { int o = __p.__offset(18); return o != 0 ? 0!=__p.bb.Get(o + __p.bb_pos) : (bool)false; } }
  public string Name { get { int o = __p.__offset(20); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetNameBytes() { return __p.__vector_as_span<byte>(20, 1); }
#else
  public ArraySegment<byte>? GetNameBytes() { return __p.__vector_as_arraysegment(20); }
#endif
  public byte[] GetNameArray() { return __p.__vector_as_array<byte>(20); }
  public int Team { get { int o = __p.__offset(22); return o != 0 ? __p.bb.GetInt(o + __p.bb_pos) : (int)0; } }
  public int Boost { get { int o = __p.__offset(24); return o != 0 ? __p.bb.GetInt(o + __p.bb_pos) : (int)0; } }
  public rlbot.flat.BoxShape? Hitbox { get { int o = __p.__offset(26); return o != 0 ? (rlbot.flat.BoxShape?)(new rlbot.flat.BoxShape()).__assign(__p.__indirect(o + __p.bb_pos), __p.bb) : null; } }
  public rlbot.flat.Vector3? HitboxOffset { get { int o = __p.__offset(28); return o != 0 ? (rlbot.flat.Vector3?)(new rlbot.flat.Vector3()).__assign(o + __p.bb_pos, __p.bb) : null; } }
  /// In the case where the requested player index is not available, spawnId will help
  /// the framework figure out what index was actually assigned to this player instead.
  public int SpawnId { get { int o = __p.__offset(30); return o != 0 ? __p.bb.GetInt(o + __p.bb_pos) : (int)0; } }

  public static void StartPlayerInfo(FlatBufferBuilder builder) { builder.StartTable(14); }
  public static void AddPhysics(FlatBufferBuilder builder, Offset<rlbot.flat.Physics> physicsOffset) { builder.AddOffset(0, physicsOffset.Value, 0); }
  public static void AddScoreInfo(FlatBufferBuilder builder, Offset<rlbot.flat.ScoreInfo> scoreInfoOffset) { builder.AddOffset(1, scoreInfoOffset.Value, 0); }
  public static void AddIsDemolished(FlatBufferBuilder builder, bool isDemolished) { builder.AddBool(2, isDemolished, false); }
  public static void AddHasWheelContact(FlatBufferBuilder builder, bool hasWheelContact) { builder.AddBool(3, hasWheelContact, false); }
  public static void AddIsSupersonic(FlatBufferBuilder builder, bool isSupersonic) { builder.AddBool(4, isSupersonic, false); }
  public static void AddIsBot(FlatBufferBuilder builder, bool isBot) { builder.AddBool(5, isBot, false); }
  public static void AddJumped(FlatBufferBuilder builder, bool jumped) { builder.AddBool(6, jumped, false); }
  public static void AddDoubleJumped(FlatBufferBuilder builder, bool doubleJumped) { builder.AddBool(7, doubleJumped, false); }
  public static void AddName(FlatBufferBuilder builder, StringOffset nameOffset) { builder.AddOffset(8, nameOffset.Value, 0); }
  public static void AddTeam(FlatBufferBuilder builder, int team) { builder.AddInt(9, team, 0); }
  public static void AddBoost(FlatBufferBuilder builder, int boost) { builder.AddInt(10, boost, 0); }
  public static void AddHitbox(FlatBufferBuilder builder, Offset<rlbot.flat.BoxShape> hitboxOffset) { builder.AddOffset(11, hitboxOffset.Value, 0); }
  public static void AddHitboxOffset(FlatBufferBuilder builder, Offset<rlbot.flat.Vector3> hitboxOffsetOffset) { builder.AddStruct(12, hitboxOffsetOffset.Value, 0); }
  public static void AddSpawnId(FlatBufferBuilder builder, int spawnId) { builder.AddInt(13, spawnId, 0); }
  public static Offset<rlbot.flat.PlayerInfo> EndPlayerInfo(FlatBufferBuilder builder) {
    int o = builder.EndTable();
    return new Offset<rlbot.flat.PlayerInfo>(o);
  }
}


static public class PlayerInfoVerify
{
  static public bool Verify(Google.FlatBuffers.Verifier verifier, uint tablePos)
  {
    return verifier.VerifyTableStart(tablePos)
      && verifier.VerifyTable(tablePos, 4 /*Physics*/, rlbot.flat.PhysicsVerify.Verify, false)
      && verifier.VerifyTable(tablePos, 6 /*ScoreInfo*/, rlbot.flat.ScoreInfoVerify.Verify, false)
      && verifier.VerifyField(tablePos, 8 /*IsDemolished*/, 1 /*bool*/, 1, false)
      && verifier.VerifyField(tablePos, 10 /*HasWheelContact*/, 1 /*bool*/, 1, false)
      && verifier.VerifyField(tablePos, 12 /*IsSupersonic*/, 1 /*bool*/, 1, false)
      && verifier.VerifyField(tablePos, 14 /*IsBot*/, 1 /*bool*/, 1, false)
      && verifier.VerifyField(tablePos, 16 /*Jumped*/, 1 /*bool*/, 1, false)
      && verifier.VerifyField(tablePos, 18 /*DoubleJumped*/, 1 /*bool*/, 1, false)
      && verifier.VerifyString(tablePos, 20 /*Name*/, false)
      && verifier.VerifyField(tablePos, 22 /*Team*/, 4 /*int*/, 4, false)
      && verifier.VerifyField(tablePos, 24 /*Boost*/, 4 /*int*/, 4, false)
      && verifier.VerifyTable(tablePos, 26 /*Hitbox*/, rlbot.flat.BoxShapeVerify.Verify, false)
      && verifier.VerifyField(tablePos, 28 /*HitboxOffset*/, 12 /*rlbot.flat.Vector3*/, 4, false)
      && verifier.VerifyField(tablePos, 30 /*SpawnId*/, 4 /*int*/, 4, false)
      && verifier.VerifyTableEnd(tablePos);
  }
}
public struct DropShotBallInfo : IFlatbufferObject
{
  private Table __p;
  public ByteBuffer ByteBuffer { get { return __p.bb; } }
  public static void ValidateVersion() { FlatBufferConstants.FLATBUFFERS_23_5_26(); }
  public static DropShotBallInfo GetRootAsDropShotBallInfo(ByteBuffer _bb) { return GetRootAsDropShotBallInfo(_bb, new DropShotBallInfo()); }
  public static DropShotBallInfo GetRootAsDropShotBallInfo(ByteBuffer _bb, DropShotBallInfo obj) { return (obj.__assign(_bb.GetInt(_bb.Position) + _bb.Position, _bb)); }
  public void __init(int _i, ByteBuffer _bb) { __p = new Table(_i, _bb); }
  public DropShotBallInfo __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }

  public float AbsorbedForce { get { int o = __p.__offset(4); return o != 0 ? __p.bb.GetFloat(o + __p.bb_pos) : (float)0.0f; } }
  public int DamageIndex { get { int o = __p.__offset(6); return o != 0 ? __p.bb.GetInt(o + __p.bb_pos) : (int)0; } }
  public float ForceAccumRecent { get { int o = __p.__offset(8); return o != 0 ? __p.bb.GetFloat(o + __p.bb_pos) : (float)0.0f; } }

  public static Offset<rlbot.flat.DropShotBallInfo> CreateDropShotBallInfo(FlatBufferBuilder builder,
      float absorbedForce = 0.0f,
      int damageIndex = 0,
      float forceAccumRecent = 0.0f) {
    builder.StartTable(3);
    DropShotBallInfo.AddForceAccumRecent(builder, forceAccumRecent);
    DropShotBallInfo.AddDamageIndex(builder, damageIndex);
    DropShotBallInfo.AddAbsorbedForce(builder, absorbedForce);
    return DropShotBallInfo.EndDropShotBallInfo(builder);
  }

  public static void StartDropShotBallInfo(FlatBufferBuilder builder) { builder.StartTable(3); }
  public static void AddAbsorbedForce(FlatBufferBuilder builder, float absorbedForce) { builder.AddFloat(0, absorbedForce, 0.0f); }
  public static void AddDamageIndex(FlatBufferBuilder builder, int damageIndex) { builder.AddInt(1, damageIndex, 0); }
  public static void AddForceAccumRecent(FlatBufferBuilder builder, float forceAccumRecent) { builder.AddFloat(2, forceAccumRecent, 0.0f); }
  public static Offset<rlbot.flat.DropShotBallInfo> EndDropShotBallInfo(FlatBufferBuilder builder) {
    int o = builder.EndTable();
    return new Offset<rlbot.flat.DropShotBallInfo>(o);
  }
}


static public class DropShotBallInfoVerify
{
  static public bool Verify(Google.FlatBuffers.Verifier verifier, uint tablePos)
  {
    return verifier.VerifyTableStart(tablePos)
      && verifier.VerifyField(tablePos, 4 /*AbsorbedForce*/, 4 /*float*/, 4, false)
      && verifier.VerifyField(tablePos, 6 /*DamageIndex*/, 4 /*int*/, 4, false)
      && verifier.VerifyField(tablePos, 8 /*ForceAccumRecent*/, 4 /*float*/, 4, false)
      && verifier.VerifyTableEnd(tablePos);
  }
}
public struct BallInfo : IFlatbufferObject
{
  private Table __p;
  public ByteBuffer ByteBuffer { get { return __p.bb; } }
  public static void ValidateVersion() { FlatBufferConstants.FLATBUFFERS_23_5_26(); }
  public static BallInfo GetRootAsBallInfo(ByteBuffer _bb) { return GetRootAsBallInfo(_bb, new BallInfo()); }
  public static BallInfo GetRootAsBallInfo(ByteBuffer _bb, BallInfo obj) { return (obj.__assign(_bb.GetInt(_bb.Position) + _bb.Position, _bb)); }
  public void __init(int _i, ByteBuffer _bb) { __p = new Table(_i, _bb); }
  public BallInfo __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }

  public rlbot.flat.Physics? Physics { get { int o = __p.__offset(4); return o != 0 ? (rlbot.flat.Physics?)(new rlbot.flat.Physics()).__assign(__p.__indirect(o + __p.bb_pos), __p.bb) : null; } }
  public rlbot.flat.Touch? LatestTouch { get { int o = __p.__offset(6); return o != 0 ? (rlbot.flat.Touch?)(new rlbot.flat.Touch()).__assign(__p.__indirect(o + __p.bb_pos), __p.bb) : null; } }
  public rlbot.flat.DropShotBallInfo? DropShotInfo { get { int o = __p.__offset(8); return o != 0 ? (rlbot.flat.DropShotBallInfo?)(new rlbot.flat.DropShotBallInfo()).__assign(__p.__indirect(o + __p.bb_pos), __p.bb) : null; } }
  public rlbot.flat.CollisionShape ShapeType { get { int o = __p.__offset(10); return o != 0 ? (rlbot.flat.CollisionShape)__p.bb.Get(o + __p.bb_pos) : rlbot.flat.CollisionShape.NONE; } }
  public TTable? Shape<TTable>() where TTable : struct, IFlatbufferObject { int o = __p.__offset(12); return o != 0 ? (TTable?)__p.__union<TTable>(o + __p.bb_pos) : null; }
  public rlbot.flat.BoxShape ShapeAsBoxShape() { return Shape<rlbot.flat.BoxShape>().Value; }
  public rlbot.flat.SphereShape ShapeAsSphereShape() { return Shape<rlbot.flat.SphereShape>().Value; }
  public rlbot.flat.CylinderShape ShapeAsCylinderShape() { return Shape<rlbot.flat.CylinderShape>().Value; }

  public static Offset<rlbot.flat.BallInfo> CreateBallInfo(FlatBufferBuilder builder,
      Offset<rlbot.flat.Physics> physicsOffset = default(Offset<rlbot.flat.Physics>),
      Offset<rlbot.flat.Touch> latestTouchOffset = default(Offset<rlbot.flat.Touch>),
      Offset<rlbot.flat.DropShotBallInfo> dropShotInfoOffset = default(Offset<rlbot.flat.DropShotBallInfo>),
      rlbot.flat.CollisionShape shape_type = rlbot.flat.CollisionShape.NONE,
      int shapeOffset = 0) {
    builder.StartTable(5);
    BallInfo.AddShape(builder, shapeOffset);
    BallInfo.AddDropShotInfo(builder, dropShotInfoOffset);
    BallInfo.AddLatestTouch(builder, latestTouchOffset);
    BallInfo.AddPhysics(builder, physicsOffset);
    BallInfo.AddShapeType(builder, shape_type);
    return BallInfo.EndBallInfo(builder);
  }

  public static void StartBallInfo(FlatBufferBuilder builder) { builder.StartTable(5); }
  public static void AddPhysics(FlatBufferBuilder builder, Offset<rlbot.flat.Physics> physicsOffset) { builder.AddOffset(0, physicsOffset.Value, 0); }
  public static void AddLatestTouch(FlatBufferBuilder builder, Offset<rlbot.flat.Touch> latestTouchOffset) { builder.AddOffset(1, latestTouchOffset.Value, 0); }
  public static void AddDropShotInfo(FlatBufferBuilder builder, Offset<rlbot.flat.DropShotBallInfo> dropShotInfoOffset) { builder.AddOffset(2, dropShotInfoOffset.Value, 0); }
  public static void AddShapeType(FlatBufferBuilder builder, rlbot.flat.CollisionShape shapeType) { builder.AddByte(3, (byte)shapeType, 0); }
  public static void AddShape(FlatBufferBuilder builder, int shapeOffset) { builder.AddOffset(4, shapeOffset, 0); }
  public static Offset<rlbot.flat.BallInfo> EndBallInfo(FlatBufferBuilder builder) {
    int o = builder.EndTable();
    return new Offset<rlbot.flat.BallInfo>(o);
  }
}


static public class BallInfoVerify
{
  static public bool Verify(Google.FlatBuffers.Verifier verifier, uint tablePos)
  {
    return verifier.VerifyTableStart(tablePos)
      && verifier.VerifyTable(tablePos, 4 /*Physics*/, rlbot.flat.PhysicsVerify.Verify, false)
      && verifier.VerifyTable(tablePos, 6 /*LatestTouch*/, rlbot.flat.TouchVerify.Verify, false)
      && verifier.VerifyTable(tablePos, 8 /*DropShotInfo*/, rlbot.flat.DropShotBallInfoVerify.Verify, false)
      && verifier.VerifyField(tablePos, 10 /*ShapeType*/, 1 /*rlbot.flat.CollisionShape*/, 1, false)
      && verifier.VerifyUnion(tablePos, 10, 12 /*Shape*/, rlbot.flat.CollisionShapeVerify.Verify, false)
      && verifier.VerifyTableEnd(tablePos);
  }
}
public struct BoostPadState : IFlatbufferObject
{
  private Table __p;
  public ByteBuffer ByteBuffer { get { return __p.bb; } }
  public static void ValidateVersion() { FlatBufferConstants.FLATBUFFERS_23_5_26(); }
  public static BoostPadState GetRootAsBoostPadState(ByteBuffer _bb) { return GetRootAsBoostPadState(_bb, new BoostPadState()); }
  public static BoostPadState GetRootAsBoostPadState(ByteBuffer _bb, BoostPadState obj) { return (obj.__assign(_bb.GetInt(_bb.Position) + _bb.Position, _bb)); }
  public void __init(int _i, ByteBuffer _bb) { __p = new Table(_i, _bb); }
  public BoostPadState __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }

  /// True if the boost can be picked up
  public bool IsActive { get { int o = __p.__offset(4); return o != 0 ? 0!=__p.bb.Get(o + __p.bb_pos) : (bool)false; } }
  /// The number of seconds since the boost has been picked up, or 0.0 if the boost is active.
  public float Timer { get { int o = __p.__offset(6); return o != 0 ? __p.bb.GetFloat(o + __p.bb_pos) : (float)0.0f; } }

  public static Offset<rlbot.flat.BoostPadState> CreateBoostPadState(FlatBufferBuilder builder,
      bool isActive = false,
      float timer = 0.0f) {
    builder.StartTable(2);
    BoostPadState.AddTimer(builder, timer);
    BoostPadState.AddIsActive(builder, isActive);
    return BoostPadState.EndBoostPadState(builder);
  }

  public static void StartBoostPadState(FlatBufferBuilder builder) { builder.StartTable(2); }
  public static void AddIsActive(FlatBufferBuilder builder, bool isActive) { builder.AddBool(0, isActive, false); }
  public static void AddTimer(FlatBufferBuilder builder, float timer) { builder.AddFloat(1, timer, 0.0f); }
  public static Offset<rlbot.flat.BoostPadState> EndBoostPadState(FlatBufferBuilder builder) {
    int o = builder.EndTable();
    return new Offset<rlbot.flat.BoostPadState>(o);
  }
}


static public class BoostPadStateVerify
{
  static public bool Verify(Google.FlatBuffers.Verifier verifier, uint tablePos)
  {
    return verifier.VerifyTableStart(tablePos)
      && verifier.VerifyField(tablePos, 4 /*IsActive*/, 1 /*bool*/, 1, false)
      && verifier.VerifyField(tablePos, 6 /*Timer*/, 4 /*float*/, 4, false)
      && verifier.VerifyTableEnd(tablePos);
  }
}
public struct DropshotTile : IFlatbufferObject
{
  private Table __p;
  public ByteBuffer ByteBuffer { get { return __p.bb; } }
  public static void ValidateVersion() { FlatBufferConstants.FLATBUFFERS_23_5_26(); }
  public static DropshotTile GetRootAsDropshotTile(ByteBuffer _bb) { return GetRootAsDropshotTile(_bb, new DropshotTile()); }
  public static DropshotTile GetRootAsDropshotTile(ByteBuffer _bb, DropshotTile obj) { return (obj.__assign(_bb.GetInt(_bb.Position) + _bb.Position, _bb)); }
  public void __init(int _i, ByteBuffer _bb) { __p = new Table(_i, _bb); }
  public DropshotTile __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }

  /// The amount of damage the tile has sustained.
  public rlbot.flat.TileState TileState { get { int o = __p.__offset(4); return o != 0 ? (rlbot.flat.TileState)__p.bb.GetSbyte(o + __p.bb_pos) : rlbot.flat.TileState.Unknown; } }

  public static Offset<rlbot.flat.DropshotTile> CreateDropshotTile(FlatBufferBuilder builder,
      rlbot.flat.TileState tileState = rlbot.flat.TileState.Unknown) {
    builder.StartTable(1);
    DropshotTile.AddTileState(builder, tileState);
    return DropshotTile.EndDropshotTile(builder);
  }

  public static void StartDropshotTile(FlatBufferBuilder builder) { builder.StartTable(1); }
  public static void AddTileState(FlatBufferBuilder builder, rlbot.flat.TileState tileState) { builder.AddSbyte(0, (sbyte)tileState, 0); }
  public static Offset<rlbot.flat.DropshotTile> EndDropshotTile(FlatBufferBuilder builder) {
    int o = builder.EndTable();
    return new Offset<rlbot.flat.DropshotTile>(o);
  }
}


static public class DropshotTileVerify
{
  static public bool Verify(Google.FlatBuffers.Verifier verifier, uint tablePos)
  {
    return verifier.VerifyTableStart(tablePos)
      && verifier.VerifyField(tablePos, 4 /*TileState*/, 1 /*rlbot.flat.TileState*/, 1, false)
      && verifier.VerifyTableEnd(tablePos);
  }
}
public struct GameInfo : IFlatbufferObject
{
  private Table __p;
  public ByteBuffer ByteBuffer { get { return __p.bb; } }
  public static void ValidateVersion() { FlatBufferConstants.FLATBUFFERS_23_5_26(); }
  public static GameInfo GetRootAsGameInfo(ByteBuffer _bb) { return GetRootAsGameInfo(_bb, new GameInfo()); }
  public static GameInfo GetRootAsGameInfo(ByteBuffer _bb, GameInfo obj) { return (obj.__assign(_bb.GetInt(_bb.Position) + _bb.Position, _bb)); }
  public void __init(int _i, ByteBuffer _bb) { __p = new Table(_i, _bb); }
  public GameInfo __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }

  public float SecondsElapsed { get { int o = __p.__offset(4); return o != 0 ? __p.bb.GetFloat(o + __p.bb_pos) : (float)0.0f; } }
  public float GameTimeRemaining { get { int o = __p.__offset(6); return o != 0 ? __p.bb.GetFloat(o + __p.bb_pos) : (float)0.0f; } }
  public bool IsOvertime { get { int o = __p.__offset(8); return o != 0 ? 0!=__p.bb.Get(o + __p.bb_pos) : (bool)false; } }
  public bool IsUnlimitedTime { get { int o = __p.__offset(10); return o != 0 ? 0!=__p.bb.Get(o + __p.bb_pos) : (bool)false; } }
  /// True when cars are allowed to move, and during the pause menu. False during replays.
  public bool IsRoundActive { get { int o = __p.__offset(12); return o != 0 ? 0!=__p.bb.Get(o + __p.bb_pos) : (bool)false; } }
  /// True when the clock is paused due to kickoff, but false during kickoff countdown. In other words, it is true
  /// while cars can move during kickoff. Note that if both players sit still, game clock start and this will become false.
  public bool IsKickoffPause { get { int o = __p.__offset(14); return o != 0 ? 0!=__p.bb.Get(o + __p.bb_pos) : (bool)false; } }
  /// Turns true after final replay, the moment the 'winner' screen appears. Remains true during next match
  /// countdown. Turns false again the moment the 'choose team' screen appears.
  public bool IsMatchEnded { get { int o = __p.__offset(16); return o != 0 ? 0!=__p.bb.Get(o + __p.bb_pos) : (bool)false; } }
  public float WorldGravityZ { get { int o = __p.__offset(18); return o != 0 ? __p.bb.GetFloat(o + __p.bb_pos) : (float)0.0f; } }
  /// Game speed multiplier, 1.0 is regular game speed.
  public float GameSpeed { get { int o = __p.__offset(20); return o != 0 ? __p.bb.GetFloat(o + __p.bb_pos) : (float)0.0f; } }
  /// Tracks the number of physics frames the game has computed.
  /// May increase by more than one across consecutive packets.
  /// Data type will roll over after 207 days at 120Hz.
  public int FrameNum { get { int o = __p.__offset(22); return o != 0 ? __p.bb.GetInt(o + __p.bb_pos) : (int)0; } }

  public static Offset<rlbot.flat.GameInfo> CreateGameInfo(FlatBufferBuilder builder,
      float secondsElapsed = 0.0f,
      float gameTimeRemaining = 0.0f,
      bool isOvertime = false,
      bool isUnlimitedTime = false,
      bool isRoundActive = false,
      bool isKickoffPause = false,
      bool isMatchEnded = false,
      float worldGravityZ = 0.0f,
      float gameSpeed = 0.0f,
      int frameNum = 0) {
    builder.StartTable(10);
    GameInfo.AddFrameNum(builder, frameNum);
    GameInfo.AddGameSpeed(builder, gameSpeed);
    GameInfo.AddWorldGravityZ(builder, worldGravityZ);
    GameInfo.AddGameTimeRemaining(builder, gameTimeRemaining);
    GameInfo.AddSecondsElapsed(builder, secondsElapsed);
    GameInfo.AddIsMatchEnded(builder, isMatchEnded);
    GameInfo.AddIsKickoffPause(builder, isKickoffPause);
    GameInfo.AddIsRoundActive(builder, isRoundActive);
    GameInfo.AddIsUnlimitedTime(builder, isUnlimitedTime);
    GameInfo.AddIsOvertime(builder, isOvertime);
    return GameInfo.EndGameInfo(builder);
  }

  public static void StartGameInfo(FlatBufferBuilder builder) { builder.StartTable(10); }
  public static void AddSecondsElapsed(FlatBufferBuilder builder, float secondsElapsed) { builder.AddFloat(0, secondsElapsed, 0.0f); }
  public static void AddGameTimeRemaining(FlatBufferBuilder builder, float gameTimeRemaining) { builder.AddFloat(1, gameTimeRemaining, 0.0f); }
  public static void AddIsOvertime(FlatBufferBuilder builder, bool isOvertime) { builder.AddBool(2, isOvertime, false); }
  public static void AddIsUnlimitedTime(FlatBufferBuilder builder, bool isUnlimitedTime) { builder.AddBool(3, isUnlimitedTime, false); }
  public static void AddIsRoundActive(FlatBufferBuilder builder, bool isRoundActive) { builder.AddBool(4, isRoundActive, false); }
  public static void AddIsKickoffPause(FlatBufferBuilder builder, bool isKickoffPause) { builder.AddBool(5, isKickoffPause, false); }
  public static void AddIsMatchEnded(FlatBufferBuilder builder, bool isMatchEnded) { builder.AddBool(6, isMatchEnded, false); }
  public static void AddWorldGravityZ(FlatBufferBuilder builder, float worldGravityZ) { builder.AddFloat(7, worldGravityZ, 0.0f); }
  public static void AddGameSpeed(FlatBufferBuilder builder, float gameSpeed) { builder.AddFloat(8, gameSpeed, 0.0f); }
  public static void AddFrameNum(FlatBufferBuilder builder, int frameNum) { builder.AddInt(9, frameNum, 0); }
  public static Offset<rlbot.flat.GameInfo> EndGameInfo(FlatBufferBuilder builder) {
    int o = builder.EndTable();
    return new Offset<rlbot.flat.GameInfo>(o);
  }
}


static public class GameInfoVerify
{
  static public bool Verify(Google.FlatBuffers.Verifier verifier, uint tablePos)
  {
    return verifier.VerifyTableStart(tablePos)
      && verifier.VerifyField(tablePos, 4 /*SecondsElapsed*/, 4 /*float*/, 4, false)
      && verifier.VerifyField(tablePos, 6 /*GameTimeRemaining*/, 4 /*float*/, 4, false)
      && verifier.VerifyField(tablePos, 8 /*IsOvertime*/, 1 /*bool*/, 1, false)
      && verifier.VerifyField(tablePos, 10 /*IsUnlimitedTime*/, 1 /*bool*/, 1, false)
      && verifier.VerifyField(tablePos, 12 /*IsRoundActive*/, 1 /*bool*/, 1, false)
      && verifier.VerifyField(tablePos, 14 /*IsKickoffPause*/, 1 /*bool*/, 1, false)
      && verifier.VerifyField(tablePos, 16 /*IsMatchEnded*/, 1 /*bool*/, 1, false)
      && verifier.VerifyField(tablePos, 18 /*WorldGravityZ*/, 4 /*float*/, 4, false)
      && verifier.VerifyField(tablePos, 20 /*GameSpeed*/, 4 /*float*/, 4, false)
      && verifier.VerifyField(tablePos, 22 /*FrameNum*/, 4 /*int*/, 4, false)
      && verifier.VerifyTableEnd(tablePos);
  }
}
public struct TeamInfo : IFlatbufferObject
{
  private Table __p;
  public ByteBuffer ByteBuffer { get { return __p.bb; } }
  public static void ValidateVersion() { FlatBufferConstants.FLATBUFFERS_23_5_26(); }
  public static TeamInfo GetRootAsTeamInfo(ByteBuffer _bb) { return GetRootAsTeamInfo(_bb, new TeamInfo()); }
  public static TeamInfo GetRootAsTeamInfo(ByteBuffer _bb, TeamInfo obj) { return (obj.__assign(_bb.GetInt(_bb.Position) + _bb.Position, _bb)); }
  public void __init(int _i, ByteBuffer _bb) { __p = new Table(_i, _bb); }
  public TeamInfo __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }

  public int TeamIndex { get { int o = __p.__offset(4); return o != 0 ? __p.bb.GetInt(o + __p.bb_pos) : (int)0; } }
  /// number of goals scored.
  public int Score { get { int o = __p.__offset(6); return o != 0 ? __p.bb.GetInt(o + __p.bb_pos) : (int)0; } }

  public static Offset<rlbot.flat.TeamInfo> CreateTeamInfo(FlatBufferBuilder builder,
      int teamIndex = 0,
      int score = 0) {
    builder.StartTable(2);
    TeamInfo.AddScore(builder, score);
    TeamInfo.AddTeamIndex(builder, teamIndex);
    return TeamInfo.EndTeamInfo(builder);
  }

  public static void StartTeamInfo(FlatBufferBuilder builder) { builder.StartTable(2); }
  public static void AddTeamIndex(FlatBufferBuilder builder, int teamIndex) { builder.AddInt(0, teamIndex, 0); }
  public static void AddScore(FlatBufferBuilder builder, int score) { builder.AddInt(1, score, 0); }
  public static Offset<rlbot.flat.TeamInfo> EndTeamInfo(FlatBufferBuilder builder) {
    int o = builder.EndTable();
    return new Offset<rlbot.flat.TeamInfo>(o);
  }
}


static public class TeamInfoVerify
{
  static public bool Verify(Google.FlatBuffers.Verifier verifier, uint tablePos)
  {
    return verifier.VerifyTableStart(tablePos)
      && verifier.VerifyField(tablePos, 4 /*TeamIndex*/, 4 /*int*/, 4, false)
      && verifier.VerifyField(tablePos, 6 /*Score*/, 4 /*int*/, 4, false)
      && verifier.VerifyTableEnd(tablePos);
  }
}
public struct GameTickPacket : IFlatbufferObject
{
  private Table __p;
  public ByteBuffer ByteBuffer { get { return __p.bb; } }
  public static void ValidateVersion() { FlatBufferConstants.FLATBUFFERS_23_5_26(); }
  public static GameTickPacket GetRootAsGameTickPacket(ByteBuffer _bb) { return GetRootAsGameTickPacket(_bb, new GameTickPacket()); }
  public static GameTickPacket GetRootAsGameTickPacket(ByteBuffer _bb, GameTickPacket obj) { return (obj.__assign(_bb.GetInt(_bb.Position) + _bb.Position, _bb)); }
  public void __init(int _i, ByteBuffer _bb) { __p = new Table(_i, _bb); }
  public GameTickPacket __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }

  public rlbot.flat.PlayerInfo? Players(int j) { int o = __p.__offset(4); return o != 0 ? (rlbot.flat.PlayerInfo?)(new rlbot.flat.PlayerInfo()).__assign(__p.__indirect(__p.__vector(o) + j * 4), __p.bb) : null; }
  public int PlayersLength { get { int o = __p.__offset(4); return o != 0 ? __p.__vector_len(o) : 0; } }
  public rlbot.flat.BoostPadState? BoostPadStates(int j) { int o = __p.__offset(6); return o != 0 ? (rlbot.flat.BoostPadState?)(new rlbot.flat.BoostPadState()).__assign(__p.__indirect(__p.__vector(o) + j * 4), __p.bb) : null; }
  public int BoostPadStatesLength { get { int o = __p.__offset(6); return o != 0 ? __p.__vector_len(o) : 0; } }
  public rlbot.flat.BallInfo? Ball { get { int o = __p.__offset(8); return o != 0 ? (rlbot.flat.BallInfo?)(new rlbot.flat.BallInfo()).__assign(__p.__indirect(o + __p.bb_pos), __p.bb) : null; } }
  public rlbot.flat.GameInfo? GameInfo { get { int o = __p.__offset(10); return o != 0 ? (rlbot.flat.GameInfo?)(new rlbot.flat.GameInfo()).__assign(__p.__indirect(o + __p.bb_pos), __p.bb) : null; } }
  public rlbot.flat.DropshotTile? TileInformation(int j) { int o = __p.__offset(12); return o != 0 ? (rlbot.flat.DropshotTile?)(new rlbot.flat.DropshotTile()).__assign(__p.__indirect(__p.__vector(o) + j * 4), __p.bb) : null; }
  public int TileInformationLength { get { int o = __p.__offset(12); return o != 0 ? __p.__vector_len(o) : 0; } }
  public rlbot.flat.TeamInfo? Teams(int j) { int o = __p.__offset(14); return o != 0 ? (rlbot.flat.TeamInfo?)(new rlbot.flat.TeamInfo()).__assign(__p.__indirect(__p.__vector(o) + j * 4), __p.bb) : null; }
  public int TeamsLength { get { int o = __p.__offset(14); return o != 0 ? __p.__vector_len(o) : 0; } }

  public static Offset<rlbot.flat.GameTickPacket> CreateGameTickPacket(FlatBufferBuilder builder,
      VectorOffset playersOffset = default(VectorOffset),
      VectorOffset boostPadStatesOffset = default(VectorOffset),
      Offset<rlbot.flat.BallInfo> ballOffset = default(Offset<rlbot.flat.BallInfo>),
      Offset<rlbot.flat.GameInfo> gameInfoOffset = default(Offset<rlbot.flat.GameInfo>),
      VectorOffset tileInformationOffset = default(VectorOffset),
      VectorOffset teamsOffset = default(VectorOffset)) {
    builder.StartTable(6);
    GameTickPacket.AddTeams(builder, teamsOffset);
    GameTickPacket.AddTileInformation(builder, tileInformationOffset);
    GameTickPacket.AddGameInfo(builder, gameInfoOffset);
    GameTickPacket.AddBall(builder, ballOffset);
    GameTickPacket.AddBoostPadStates(builder, boostPadStatesOffset);
    GameTickPacket.AddPlayers(builder, playersOffset);
    return GameTickPacket.EndGameTickPacket(builder);
  }

  public static void StartGameTickPacket(FlatBufferBuilder builder) { builder.StartTable(6); }
  public static void AddPlayers(FlatBufferBuilder builder, VectorOffset playersOffset) { builder.AddOffset(0, playersOffset.Value, 0); }
  public static VectorOffset CreatePlayersVector(FlatBufferBuilder builder, Offset<rlbot.flat.PlayerInfo>[] data) { builder.StartVector(4, data.Length, 4); for (int i = data.Length - 1; i >= 0; i--) builder.AddOffset(data[i].Value); return builder.EndVector(); }
  public static VectorOffset CreatePlayersVectorBlock(FlatBufferBuilder builder, Offset<rlbot.flat.PlayerInfo>[] data) { builder.StartVector(4, data.Length, 4); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreatePlayersVectorBlock(FlatBufferBuilder builder, ArraySegment<Offset<rlbot.flat.PlayerInfo>> data) { builder.StartVector(4, data.Count, 4); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreatePlayersVectorBlock(FlatBufferBuilder builder, IntPtr dataPtr, int sizeInBytes) { builder.StartVector(1, sizeInBytes, 1); builder.Add<Offset<rlbot.flat.PlayerInfo>>(dataPtr, sizeInBytes); return builder.EndVector(); }
  public static void StartPlayersVector(FlatBufferBuilder builder, int numElems) { builder.StartVector(4, numElems, 4); }
  public static void AddBoostPadStates(FlatBufferBuilder builder, VectorOffset boostPadStatesOffset) { builder.AddOffset(1, boostPadStatesOffset.Value, 0); }
  public static VectorOffset CreateBoostPadStatesVector(FlatBufferBuilder builder, Offset<rlbot.flat.BoostPadState>[] data) { builder.StartVector(4, data.Length, 4); for (int i = data.Length - 1; i >= 0; i--) builder.AddOffset(data[i].Value); return builder.EndVector(); }
  public static VectorOffset CreateBoostPadStatesVectorBlock(FlatBufferBuilder builder, Offset<rlbot.flat.BoostPadState>[] data) { builder.StartVector(4, data.Length, 4); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreateBoostPadStatesVectorBlock(FlatBufferBuilder builder, ArraySegment<Offset<rlbot.flat.BoostPadState>> data) { builder.StartVector(4, data.Count, 4); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreateBoostPadStatesVectorBlock(FlatBufferBuilder builder, IntPtr dataPtr, int sizeInBytes) { builder.StartVector(1, sizeInBytes, 1); builder.Add<Offset<rlbot.flat.BoostPadState>>(dataPtr, sizeInBytes); return builder.EndVector(); }
  public static void StartBoostPadStatesVector(FlatBufferBuilder builder, int numElems) { builder.StartVector(4, numElems, 4); }
  public static void AddBall(FlatBufferBuilder builder, Offset<rlbot.flat.BallInfo> ballOffset) { builder.AddOffset(2, ballOffset.Value, 0); }
  public static void AddGameInfo(FlatBufferBuilder builder, Offset<rlbot.flat.GameInfo> gameInfoOffset) { builder.AddOffset(3, gameInfoOffset.Value, 0); }
  public static void AddTileInformation(FlatBufferBuilder builder, VectorOffset tileInformationOffset) { builder.AddOffset(4, tileInformationOffset.Value, 0); }
  public static VectorOffset CreateTileInformationVector(FlatBufferBuilder builder, Offset<rlbot.flat.DropshotTile>[] data) { builder.StartVector(4, data.Length, 4); for (int i = data.Length - 1; i >= 0; i--) builder.AddOffset(data[i].Value); return builder.EndVector(); }
  public static VectorOffset CreateTileInformationVectorBlock(FlatBufferBuilder builder, Offset<rlbot.flat.DropshotTile>[] data) { builder.StartVector(4, data.Length, 4); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreateTileInformationVectorBlock(FlatBufferBuilder builder, ArraySegment<Offset<rlbot.flat.DropshotTile>> data) { builder.StartVector(4, data.Count, 4); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreateTileInformationVectorBlock(FlatBufferBuilder builder, IntPtr dataPtr, int sizeInBytes) { builder.StartVector(1, sizeInBytes, 1); builder.Add<Offset<rlbot.flat.DropshotTile>>(dataPtr, sizeInBytes); return builder.EndVector(); }
  public static void StartTileInformationVector(FlatBufferBuilder builder, int numElems) { builder.StartVector(4, numElems, 4); }
  public static void AddTeams(FlatBufferBuilder builder, VectorOffset teamsOffset) { builder.AddOffset(5, teamsOffset.Value, 0); }
  public static VectorOffset CreateTeamsVector(FlatBufferBuilder builder, Offset<rlbot.flat.TeamInfo>[] data) { builder.StartVector(4, data.Length, 4); for (int i = data.Length - 1; i >= 0; i--) builder.AddOffset(data[i].Value); return builder.EndVector(); }
  public static VectorOffset CreateTeamsVectorBlock(FlatBufferBuilder builder, Offset<rlbot.flat.TeamInfo>[] data) { builder.StartVector(4, data.Length, 4); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreateTeamsVectorBlock(FlatBufferBuilder builder, ArraySegment<Offset<rlbot.flat.TeamInfo>> data) { builder.StartVector(4, data.Count, 4); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreateTeamsVectorBlock(FlatBufferBuilder builder, IntPtr dataPtr, int sizeInBytes) { builder.StartVector(1, sizeInBytes, 1); builder.Add<Offset<rlbot.flat.TeamInfo>>(dataPtr, sizeInBytes); return builder.EndVector(); }
  public static void StartTeamsVector(FlatBufferBuilder builder, int numElems) { builder.StartVector(4, numElems, 4); }
  public static Offset<rlbot.flat.GameTickPacket> EndGameTickPacket(FlatBufferBuilder builder) {
    int o = builder.EndTable();
    return new Offset<rlbot.flat.GameTickPacket>(o);
  }
}


static public class GameTickPacketVerify
{
  static public bool Verify(Google.FlatBuffers.Verifier verifier, uint tablePos)
  {
    return verifier.VerifyTableStart(tablePos)
      && verifier.VerifyVectorOfTables(tablePos, 4 /*Players*/, rlbot.flat.PlayerInfoVerify.Verify, false)
      && verifier.VerifyVectorOfTables(tablePos, 6 /*BoostPadStates*/, rlbot.flat.BoostPadStateVerify.Verify, false)
      && verifier.VerifyTable(tablePos, 8 /*Ball*/, rlbot.flat.BallInfoVerify.Verify, false)
      && verifier.VerifyTable(tablePos, 10 /*GameInfo*/, rlbot.flat.GameInfoVerify.Verify, false)
      && verifier.VerifyVectorOfTables(tablePos, 12 /*TileInformation*/, rlbot.flat.DropshotTileVerify.Verify, false)
      && verifier.VerifyVectorOfTables(tablePos, 14 /*Teams*/, rlbot.flat.TeamInfoVerify.Verify, false)
      && verifier.VerifyTableEnd(tablePos);
  }
}
/// The state of a rigid body in Rocket League's physics engine.
/// This gets updated in time with the physics tick, not the rendering framerate.
/// The frame field will be incremented every time the physics engine ticks.
public struct RigidBodyState : IFlatbufferObject
{
  private Table __p;
  public ByteBuffer ByteBuffer { get { return __p.bb; } }
  public static void ValidateVersion() { FlatBufferConstants.FLATBUFFERS_23_5_26(); }
  public static RigidBodyState GetRootAsRigidBodyState(ByteBuffer _bb) { return GetRootAsRigidBodyState(_bb, new RigidBodyState()); }
  public static RigidBodyState GetRootAsRigidBodyState(ByteBuffer _bb, RigidBodyState obj) { return (obj.__assign(_bb.GetInt(_bb.Position) + _bb.Position, _bb)); }
  public void __init(int _i, ByteBuffer _bb) { __p = new Table(_i, _bb); }
  public RigidBodyState __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }

  public int Frame { get { int o = __p.__offset(4); return o != 0 ? __p.bb.GetInt(o + __p.bb_pos) : (int)0; } }
  public rlbot.flat.Vector3? Location { get { int o = __p.__offset(6); return o != 0 ? (rlbot.flat.Vector3?)(new rlbot.flat.Vector3()).__assign(o + __p.bb_pos, __p.bb) : null; } }
  public rlbot.flat.Quaternion? Rotation { get { int o = __p.__offset(8); return o != 0 ? (rlbot.flat.Quaternion?)(new rlbot.flat.Quaternion()).__assign(o + __p.bb_pos, __p.bb) : null; } }
  public rlbot.flat.Vector3? Velocity { get { int o = __p.__offset(10); return o != 0 ? (rlbot.flat.Vector3?)(new rlbot.flat.Vector3()).__assign(o + __p.bb_pos, __p.bb) : null; } }
  public rlbot.flat.Vector3? AngularVelocity { get { int o = __p.__offset(12); return o != 0 ? (rlbot.flat.Vector3?)(new rlbot.flat.Vector3()).__assign(o + __p.bb_pos, __p.bb) : null; } }

  public static void StartRigidBodyState(FlatBufferBuilder builder) { builder.StartTable(5); }
  public static void AddFrame(FlatBufferBuilder builder, int frame) { builder.AddInt(0, frame, 0); }
  public static void AddLocation(FlatBufferBuilder builder, Offset<rlbot.flat.Vector3> locationOffset) { builder.AddStruct(1, locationOffset.Value, 0); }
  public static void AddRotation(FlatBufferBuilder builder, Offset<rlbot.flat.Quaternion> rotationOffset) { builder.AddStruct(2, rotationOffset.Value, 0); }
  public static void AddVelocity(FlatBufferBuilder builder, Offset<rlbot.flat.Vector3> velocityOffset) { builder.AddStruct(3, velocityOffset.Value, 0); }
  public static void AddAngularVelocity(FlatBufferBuilder builder, Offset<rlbot.flat.Vector3> angularVelocityOffset) { builder.AddStruct(4, angularVelocityOffset.Value, 0); }
  public static Offset<rlbot.flat.RigidBodyState> EndRigidBodyState(FlatBufferBuilder builder) {
    int o = builder.EndTable();
    return new Offset<rlbot.flat.RigidBodyState>(o);
  }
}


static public class RigidBodyStateVerify
{
  static public bool Verify(Google.FlatBuffers.Verifier verifier, uint tablePos)
  {
    return verifier.VerifyTableStart(tablePos)
      && verifier.VerifyField(tablePos, 4 /*Frame*/, 4 /*int*/, 4, false)
      && verifier.VerifyField(tablePos, 6 /*Location*/, 12 /*rlbot.flat.Vector3*/, 4, false)
      && verifier.VerifyField(tablePos, 8 /*Rotation*/, 16 /*rlbot.flat.Quaternion*/, 4, false)
      && verifier.VerifyField(tablePos, 10 /*Velocity*/, 12 /*rlbot.flat.Vector3*/, 4, false)
      && verifier.VerifyField(tablePos, 12 /*AngularVelocity*/, 12 /*rlbot.flat.Vector3*/, 4, false)
      && verifier.VerifyTableEnd(tablePos);
  }
}
/// Rigid body state for a player / car in the game. Includes the latest
/// controller input, which is otherwise difficult to correlate with consequences.
public struct PlayerRigidBodyState : IFlatbufferObject
{
  private Table __p;
  public ByteBuffer ByteBuffer { get { return __p.bb; } }
  public static void ValidateVersion() { FlatBufferConstants.FLATBUFFERS_23_5_26(); }
  public static PlayerRigidBodyState GetRootAsPlayerRigidBodyState(ByteBuffer _bb) { return GetRootAsPlayerRigidBodyState(_bb, new PlayerRigidBodyState()); }
  public static PlayerRigidBodyState GetRootAsPlayerRigidBodyState(ByteBuffer _bb, PlayerRigidBodyState obj) { return (obj.__assign(_bb.GetInt(_bb.Position) + _bb.Position, _bb)); }
  public void __init(int _i, ByteBuffer _bb) { __p = new Table(_i, _bb); }
  public PlayerRigidBodyState __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }

  public rlbot.flat.RigidBodyState? State { get { int o = __p.__offset(4); return o != 0 ? (rlbot.flat.RigidBodyState?)(new rlbot.flat.RigidBodyState()).__assign(__p.__indirect(o + __p.bb_pos), __p.bb) : null; } }
  public rlbot.flat.ControllerState? Input { get { int o = __p.__offset(6); return o != 0 ? (rlbot.flat.ControllerState?)(new rlbot.flat.ControllerState()).__assign(__p.__indirect(o + __p.bb_pos), __p.bb) : null; } }

  public static Offset<rlbot.flat.PlayerRigidBodyState> CreatePlayerRigidBodyState(FlatBufferBuilder builder,
      Offset<rlbot.flat.RigidBodyState> stateOffset = default(Offset<rlbot.flat.RigidBodyState>),
      Offset<rlbot.flat.ControllerState> inputOffset = default(Offset<rlbot.flat.ControllerState>)) {
    builder.StartTable(2);
    PlayerRigidBodyState.AddInput(builder, inputOffset);
    PlayerRigidBodyState.AddState(builder, stateOffset);
    return PlayerRigidBodyState.EndPlayerRigidBodyState(builder);
  }

  public static void StartPlayerRigidBodyState(FlatBufferBuilder builder) { builder.StartTable(2); }
  public static void AddState(FlatBufferBuilder builder, Offset<rlbot.flat.RigidBodyState> stateOffset) { builder.AddOffset(0, stateOffset.Value, 0); }
  public static void AddInput(FlatBufferBuilder builder, Offset<rlbot.flat.ControllerState> inputOffset) { builder.AddOffset(1, inputOffset.Value, 0); }
  public static Offset<rlbot.flat.PlayerRigidBodyState> EndPlayerRigidBodyState(FlatBufferBuilder builder) {
    int o = builder.EndTable();
    return new Offset<rlbot.flat.PlayerRigidBodyState>(o);
  }
}


static public class PlayerRigidBodyStateVerify
{
  static public bool Verify(Google.FlatBuffers.Verifier verifier, uint tablePos)
  {
    return verifier.VerifyTableStart(tablePos)
      && verifier.VerifyTable(tablePos, 4 /*State*/, rlbot.flat.RigidBodyStateVerify.Verify, false)
      && verifier.VerifyTable(tablePos, 6 /*Input*/, rlbot.flat.ControllerStateVerify.Verify, false)
      && verifier.VerifyTableEnd(tablePos);
  }
}
/// Rigid body state for the ball.
public struct BallRigidBodyState : IFlatbufferObject
{
  private Table __p;
  public ByteBuffer ByteBuffer { get { return __p.bb; } }
  public static void ValidateVersion() { FlatBufferConstants.FLATBUFFERS_23_5_26(); }
  public static BallRigidBodyState GetRootAsBallRigidBodyState(ByteBuffer _bb) { return GetRootAsBallRigidBodyState(_bb, new BallRigidBodyState()); }
  public static BallRigidBodyState GetRootAsBallRigidBodyState(ByteBuffer _bb, BallRigidBodyState obj) { return (obj.__assign(_bb.GetInt(_bb.Position) + _bb.Position, _bb)); }
  public void __init(int _i, ByteBuffer _bb) { __p = new Table(_i, _bb); }
  public BallRigidBodyState __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }

  public rlbot.flat.RigidBodyState? State { get { int o = __p.__offset(4); return o != 0 ? (rlbot.flat.RigidBodyState?)(new rlbot.flat.RigidBodyState()).__assign(__p.__indirect(o + __p.bb_pos), __p.bb) : null; } }

  public static Offset<rlbot.flat.BallRigidBodyState> CreateBallRigidBodyState(FlatBufferBuilder builder,
      Offset<rlbot.flat.RigidBodyState> stateOffset = default(Offset<rlbot.flat.RigidBodyState>)) {
    builder.StartTable(1);
    BallRigidBodyState.AddState(builder, stateOffset);
    return BallRigidBodyState.EndBallRigidBodyState(builder);
  }

  public static void StartBallRigidBodyState(FlatBufferBuilder builder) { builder.StartTable(1); }
  public static void AddState(FlatBufferBuilder builder, Offset<rlbot.flat.RigidBodyState> stateOffset) { builder.AddOffset(0, stateOffset.Value, 0); }
  public static Offset<rlbot.flat.BallRigidBodyState> EndBallRigidBodyState(FlatBufferBuilder builder) {
    int o = builder.EndTable();
    return new Offset<rlbot.flat.BallRigidBodyState>(o);
  }
}


static public class BallRigidBodyStateVerify
{
  static public bool Verify(Google.FlatBuffers.Verifier verifier, uint tablePos)
  {
    return verifier.VerifyTableStart(tablePos)
      && verifier.VerifyTable(tablePos, 4 /*State*/, rlbot.flat.RigidBodyStateVerify.Verify, false)
      && verifier.VerifyTableEnd(tablePos);
  }
}
/// Contains all rigid body state information.
public struct RigidBodyTick : IFlatbufferObject
{
  private Table __p;
  public ByteBuffer ByteBuffer { get { return __p.bb; } }
  public static void ValidateVersion() { FlatBufferConstants.FLATBUFFERS_23_5_26(); }
  public static RigidBodyTick GetRootAsRigidBodyTick(ByteBuffer _bb) { return GetRootAsRigidBodyTick(_bb, new RigidBodyTick()); }
  public static RigidBodyTick GetRootAsRigidBodyTick(ByteBuffer _bb, RigidBodyTick obj) { return (obj.__assign(_bb.GetInt(_bb.Position) + _bb.Position, _bb)); }
  public void __init(int _i, ByteBuffer _bb) { __p = new Table(_i, _bb); }
  public RigidBodyTick __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }

  public rlbot.flat.BallRigidBodyState? Ball { get { int o = __p.__offset(4); return o != 0 ? (rlbot.flat.BallRigidBodyState?)(new rlbot.flat.BallRigidBodyState()).__assign(__p.__indirect(o + __p.bb_pos), __p.bb) : null; } }
  public rlbot.flat.PlayerRigidBodyState? Players(int j) { int o = __p.__offset(6); return o != 0 ? (rlbot.flat.PlayerRigidBodyState?)(new rlbot.flat.PlayerRigidBodyState()).__assign(__p.__indirect(__p.__vector(o) + j * 4), __p.bb) : null; }
  public int PlayersLength { get { int o = __p.__offset(6); return o != 0 ? __p.__vector_len(o) : 0; } }

  public static Offset<rlbot.flat.RigidBodyTick> CreateRigidBodyTick(FlatBufferBuilder builder,
      Offset<rlbot.flat.BallRigidBodyState> ballOffset = default(Offset<rlbot.flat.BallRigidBodyState>),
      VectorOffset playersOffset = default(VectorOffset)) {
    builder.StartTable(2);
    RigidBodyTick.AddPlayers(builder, playersOffset);
    RigidBodyTick.AddBall(builder, ballOffset);
    return RigidBodyTick.EndRigidBodyTick(builder);
  }

  public static void StartRigidBodyTick(FlatBufferBuilder builder) { builder.StartTable(2); }
  public static void AddBall(FlatBufferBuilder builder, Offset<rlbot.flat.BallRigidBodyState> ballOffset) { builder.AddOffset(0, ballOffset.Value, 0); }
  public static void AddPlayers(FlatBufferBuilder builder, VectorOffset playersOffset) { builder.AddOffset(1, playersOffset.Value, 0); }
  public static VectorOffset CreatePlayersVector(FlatBufferBuilder builder, Offset<rlbot.flat.PlayerRigidBodyState>[] data) { builder.StartVector(4, data.Length, 4); for (int i = data.Length - 1; i >= 0; i--) builder.AddOffset(data[i].Value); return builder.EndVector(); }
  public static VectorOffset CreatePlayersVectorBlock(FlatBufferBuilder builder, Offset<rlbot.flat.PlayerRigidBodyState>[] data) { builder.StartVector(4, data.Length, 4); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreatePlayersVectorBlock(FlatBufferBuilder builder, ArraySegment<Offset<rlbot.flat.PlayerRigidBodyState>> data) { builder.StartVector(4, data.Count, 4); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreatePlayersVectorBlock(FlatBufferBuilder builder, IntPtr dataPtr, int sizeInBytes) { builder.StartVector(1, sizeInBytes, 1); builder.Add<Offset<rlbot.flat.PlayerRigidBodyState>>(dataPtr, sizeInBytes); return builder.EndVector(); }
  public static void StartPlayersVector(FlatBufferBuilder builder, int numElems) { builder.StartVector(4, numElems, 4); }
  public static Offset<rlbot.flat.RigidBodyTick> EndRigidBodyTick(FlatBufferBuilder builder) {
    int o = builder.EndTable();
    return new Offset<rlbot.flat.RigidBodyTick>(o);
  }
}


static public class RigidBodyTickVerify
{
  static public bool Verify(Google.FlatBuffers.Verifier verifier, uint tablePos)
  {
    return verifier.VerifyTableStart(tablePos)
      && verifier.VerifyTable(tablePos, 4 /*Ball*/, rlbot.flat.BallRigidBodyStateVerify.Verify, false)
      && verifier.VerifyVectorOfTables(tablePos, 6 /*Players*/, rlbot.flat.PlayerRigidBodyStateVerify.Verify, false)
      && verifier.VerifyTableEnd(tablePos);
  }
}
public struct GoalInfo : IFlatbufferObject
{
  private Table __p;
  public ByteBuffer ByteBuffer { get { return __p.bb; } }
  public static void ValidateVersion() { FlatBufferConstants.FLATBUFFERS_23_5_26(); }
  public static GoalInfo GetRootAsGoalInfo(ByteBuffer _bb) { return GetRootAsGoalInfo(_bb, new GoalInfo()); }
  public static GoalInfo GetRootAsGoalInfo(ByteBuffer _bb, GoalInfo obj) { return (obj.__assign(_bb.GetInt(_bb.Position) + _bb.Position, _bb)); }
  public void __init(int _i, ByteBuffer _bb) { __p = new Table(_i, _bb); }
  public GoalInfo __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }

  public int TeamNum { get { int o = __p.__offset(4); return o != 0 ? __p.bb.GetInt(o + __p.bb_pos) : (int)0; } }
  public rlbot.flat.Vector3? Location { get { int o = __p.__offset(6); return o != 0 ? (rlbot.flat.Vector3?)(new rlbot.flat.Vector3()).__assign(o + __p.bb_pos, __p.bb) : null; } }
  public rlbot.flat.Vector3? Direction { get { int o = __p.__offset(8); return o != 0 ? (rlbot.flat.Vector3?)(new rlbot.flat.Vector3()).__assign(o + __p.bb_pos, __p.bb) : null; } }
  public float Width { get { int o = __p.__offset(10); return o != 0 ? __p.bb.GetFloat(o + __p.bb_pos) : (float)0.0f; } }
  public float Height { get { int o = __p.__offset(12); return o != 0 ? __p.bb.GetFloat(o + __p.bb_pos) : (float)0.0f; } }

  public static void StartGoalInfo(FlatBufferBuilder builder) { builder.StartTable(5); }
  public static void AddTeamNum(FlatBufferBuilder builder, int teamNum) { builder.AddInt(0, teamNum, 0); }
  public static void AddLocation(FlatBufferBuilder builder, Offset<rlbot.flat.Vector3> locationOffset) { builder.AddStruct(1, locationOffset.Value, 0); }
  public static void AddDirection(FlatBufferBuilder builder, Offset<rlbot.flat.Vector3> directionOffset) { builder.AddStruct(2, directionOffset.Value, 0); }
  public static void AddWidth(FlatBufferBuilder builder, float width) { builder.AddFloat(3, width, 0.0f); }
  public static void AddHeight(FlatBufferBuilder builder, float height) { builder.AddFloat(4, height, 0.0f); }
  public static Offset<rlbot.flat.GoalInfo> EndGoalInfo(FlatBufferBuilder builder) {
    int o = builder.EndTable();
    return new Offset<rlbot.flat.GoalInfo>(o);
  }
}


static public class GoalInfoVerify
{
  static public bool Verify(Google.FlatBuffers.Verifier verifier, uint tablePos)
  {
    return verifier.VerifyTableStart(tablePos)
      && verifier.VerifyField(tablePos, 4 /*TeamNum*/, 4 /*int*/, 4, false)
      && verifier.VerifyField(tablePos, 6 /*Location*/, 12 /*rlbot.flat.Vector3*/, 4, false)
      && verifier.VerifyField(tablePos, 8 /*Direction*/, 12 /*rlbot.flat.Vector3*/, 4, false)
      && verifier.VerifyField(tablePos, 10 /*Width*/, 4 /*float*/, 4, false)
      && verifier.VerifyField(tablePos, 12 /*Height*/, 4 /*float*/, 4, false)
      && verifier.VerifyTableEnd(tablePos);
  }
}
public struct BoostPad : IFlatbufferObject
{
  private Table __p;
  public ByteBuffer ByteBuffer { get { return __p.bb; } }
  public static void ValidateVersion() { FlatBufferConstants.FLATBUFFERS_23_5_26(); }
  public static BoostPad GetRootAsBoostPad(ByteBuffer _bb) { return GetRootAsBoostPad(_bb, new BoostPad()); }
  public static BoostPad GetRootAsBoostPad(ByteBuffer _bb, BoostPad obj) { return (obj.__assign(_bb.GetInt(_bb.Position) + _bb.Position, _bb)); }
  public void __init(int _i, ByteBuffer _bb) { __p = new Table(_i, _bb); }
  public BoostPad __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }

  public rlbot.flat.Vector3? Location { get { int o = __p.__offset(4); return o != 0 ? (rlbot.flat.Vector3?)(new rlbot.flat.Vector3()).__assign(o + __p.bb_pos, __p.bb) : null; } }
  public bool IsFullBoost { get { int o = __p.__offset(6); return o != 0 ? 0!=__p.bb.Get(o + __p.bb_pos) : (bool)false; } }

  public static void StartBoostPad(FlatBufferBuilder builder) { builder.StartTable(2); }
  public static void AddLocation(FlatBufferBuilder builder, Offset<rlbot.flat.Vector3> locationOffset) { builder.AddStruct(0, locationOffset.Value, 0); }
  public static void AddIsFullBoost(FlatBufferBuilder builder, bool isFullBoost) { builder.AddBool(1, isFullBoost, false); }
  public static Offset<rlbot.flat.BoostPad> EndBoostPad(FlatBufferBuilder builder) {
    int o = builder.EndTable();
    return new Offset<rlbot.flat.BoostPad>(o);
  }
}


static public class BoostPadVerify
{
  static public bool Verify(Google.FlatBuffers.Verifier verifier, uint tablePos)
  {
    return verifier.VerifyTableStart(tablePos)
      && verifier.VerifyField(tablePos, 4 /*Location*/, 12 /*rlbot.flat.Vector3*/, 4, false)
      && verifier.VerifyField(tablePos, 6 /*IsFullBoost*/, 1 /*bool*/, 1, false)
      && verifier.VerifyTableEnd(tablePos);
  }
}
public struct FieldInfo : IFlatbufferObject
{
  private Table __p;
  public ByteBuffer ByteBuffer { get { return __p.bb; } }
  public static void ValidateVersion() { FlatBufferConstants.FLATBUFFERS_23_5_26(); }
  public static FieldInfo GetRootAsFieldInfo(ByteBuffer _bb) { return GetRootAsFieldInfo(_bb, new FieldInfo()); }
  public static FieldInfo GetRootAsFieldInfo(ByteBuffer _bb, FieldInfo obj) { return (obj.__assign(_bb.GetInt(_bb.Position) + _bb.Position, _bb)); }
  public void __init(int _i, ByteBuffer _bb) { __p = new Table(_i, _bb); }
  public FieldInfo __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }

  public rlbot.flat.BoostPad? BoostPads(int j) { int o = __p.__offset(4); return o != 0 ? (rlbot.flat.BoostPad?)(new rlbot.flat.BoostPad()).__assign(__p.__indirect(__p.__vector(o) + j * 4), __p.bb) : null; }
  public int BoostPadsLength { get { int o = __p.__offset(4); return o != 0 ? __p.__vector_len(o) : 0; } }
  public rlbot.flat.GoalInfo? Goals(int j) { int o = __p.__offset(6); return o != 0 ? (rlbot.flat.GoalInfo?)(new rlbot.flat.GoalInfo()).__assign(__p.__indirect(__p.__vector(o) + j * 4), __p.bb) : null; }
  public int GoalsLength { get { int o = __p.__offset(6); return o != 0 ? __p.__vector_len(o) : 0; } }

  public static Offset<rlbot.flat.FieldInfo> CreateFieldInfo(FlatBufferBuilder builder,
      VectorOffset boostPadsOffset = default(VectorOffset),
      VectorOffset goalsOffset = default(VectorOffset)) {
    builder.StartTable(2);
    FieldInfo.AddGoals(builder, goalsOffset);
    FieldInfo.AddBoostPads(builder, boostPadsOffset);
    return FieldInfo.EndFieldInfo(builder);
  }

  public static void StartFieldInfo(FlatBufferBuilder builder) { builder.StartTable(2); }
  public static void AddBoostPads(FlatBufferBuilder builder, VectorOffset boostPadsOffset) { builder.AddOffset(0, boostPadsOffset.Value, 0); }
  public static VectorOffset CreateBoostPadsVector(FlatBufferBuilder builder, Offset<rlbot.flat.BoostPad>[] data) { builder.StartVector(4, data.Length, 4); for (int i = data.Length - 1; i >= 0; i--) builder.AddOffset(data[i].Value); return builder.EndVector(); }
  public static VectorOffset CreateBoostPadsVectorBlock(FlatBufferBuilder builder, Offset<rlbot.flat.BoostPad>[] data) { builder.StartVector(4, data.Length, 4); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreateBoostPadsVectorBlock(FlatBufferBuilder builder, ArraySegment<Offset<rlbot.flat.BoostPad>> data) { builder.StartVector(4, data.Count, 4); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreateBoostPadsVectorBlock(FlatBufferBuilder builder, IntPtr dataPtr, int sizeInBytes) { builder.StartVector(1, sizeInBytes, 1); builder.Add<Offset<rlbot.flat.BoostPad>>(dataPtr, sizeInBytes); return builder.EndVector(); }
  public static void StartBoostPadsVector(FlatBufferBuilder builder, int numElems) { builder.StartVector(4, numElems, 4); }
  public static void AddGoals(FlatBufferBuilder builder, VectorOffset goalsOffset) { builder.AddOffset(1, goalsOffset.Value, 0); }
  public static VectorOffset CreateGoalsVector(FlatBufferBuilder builder, Offset<rlbot.flat.GoalInfo>[] data) { builder.StartVector(4, data.Length, 4); for (int i = data.Length - 1; i >= 0; i--) builder.AddOffset(data[i].Value); return builder.EndVector(); }
  public static VectorOffset CreateGoalsVectorBlock(FlatBufferBuilder builder, Offset<rlbot.flat.GoalInfo>[] data) { builder.StartVector(4, data.Length, 4); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreateGoalsVectorBlock(FlatBufferBuilder builder, ArraySegment<Offset<rlbot.flat.GoalInfo>> data) { builder.StartVector(4, data.Count, 4); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreateGoalsVectorBlock(FlatBufferBuilder builder, IntPtr dataPtr, int sizeInBytes) { builder.StartVector(1, sizeInBytes, 1); builder.Add<Offset<rlbot.flat.GoalInfo>>(dataPtr, sizeInBytes); return builder.EndVector(); }
  public static void StartGoalsVector(FlatBufferBuilder builder, int numElems) { builder.StartVector(4, numElems, 4); }
  public static Offset<rlbot.flat.FieldInfo> EndFieldInfo(FlatBufferBuilder builder) {
    int o = builder.EndTable();
    return new Offset<rlbot.flat.FieldInfo>(o);
  }
}


static public class FieldInfoVerify
{
  static public bool Verify(Google.FlatBuffers.Verifier verifier, uint tablePos)
  {
    return verifier.VerifyTableStart(tablePos)
      && verifier.VerifyVectorOfTables(tablePos, 4 /*BoostPads*/, rlbot.flat.BoostPadVerify.Verify, false)
      && verifier.VerifyVectorOfTables(tablePos, 6 /*Goals*/, rlbot.flat.GoalInfoVerify.Verify, false)
      && verifier.VerifyTableEnd(tablePos);
  }
}
public struct Float : IFlatbufferObject
{
  private Struct __p;
  public ByteBuffer ByteBuffer { get { return __p.bb; } }
  public void __init(int _i, ByteBuffer _bb) { __p = new Struct(_i, _bb); }
  public Float __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }

  public float Val { get { return __p.bb.GetFloat(__p.bb_pos + 0); } }

  public static Offset<rlbot.flat.Float> CreateFloat(FlatBufferBuilder builder, float Val) {
    builder.Prep(4, 4);
    builder.PutFloat(Val);
    return new Offset<rlbot.flat.Float>(builder.Offset);
  }
}

public struct Bool : IFlatbufferObject
{
  private Struct __p;
  public ByteBuffer ByteBuffer { get { return __p.bb; } }
  public void __init(int _i, ByteBuffer _bb) { __p = new Struct(_i, _bb); }
  public Bool __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }

  public bool Val { get { return 0!=__p.bb.Get(__p.bb_pos + 0); } }

  public static Offset<rlbot.flat.Bool> CreateBool(FlatBufferBuilder builder, bool Val) {
    builder.Prep(1, 1);
    builder.PutBool(Val);
    return new Offset<rlbot.flat.Bool>(builder.Offset);
  }
}

public struct Vector3Partial : IFlatbufferObject
{
  private Table __p;
  public ByteBuffer ByteBuffer { get { return __p.bb; } }
  public static void ValidateVersion() { FlatBufferConstants.FLATBUFFERS_23_5_26(); }
  public static Vector3Partial GetRootAsVector3Partial(ByteBuffer _bb) { return GetRootAsVector3Partial(_bb, new Vector3Partial()); }
  public static Vector3Partial GetRootAsVector3Partial(ByteBuffer _bb, Vector3Partial obj) { return (obj.__assign(_bb.GetInt(_bb.Position) + _bb.Position, _bb)); }
  public void __init(int _i, ByteBuffer _bb) { __p = new Table(_i, _bb); }
  public Vector3Partial __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }

  public rlbot.flat.Float? X { get { int o = __p.__offset(4); return o != 0 ? (rlbot.flat.Float?)(new rlbot.flat.Float()).__assign(o + __p.bb_pos, __p.bb) : null; } }
  public rlbot.flat.Float? Y { get { int o = __p.__offset(6); return o != 0 ? (rlbot.flat.Float?)(new rlbot.flat.Float()).__assign(o + __p.bb_pos, __p.bb) : null; } }
  public rlbot.flat.Float? Z { get { int o = __p.__offset(8); return o != 0 ? (rlbot.flat.Float?)(new rlbot.flat.Float()).__assign(o + __p.bb_pos, __p.bb) : null; } }

  public static void StartVector3Partial(FlatBufferBuilder builder) { builder.StartTable(3); }
  public static void AddX(FlatBufferBuilder builder, Offset<rlbot.flat.Float> xOffset) { builder.AddStruct(0, xOffset.Value, 0); }
  public static void AddY(FlatBufferBuilder builder, Offset<rlbot.flat.Float> yOffset) { builder.AddStruct(1, yOffset.Value, 0); }
  public static void AddZ(FlatBufferBuilder builder, Offset<rlbot.flat.Float> zOffset) { builder.AddStruct(2, zOffset.Value, 0); }
  public static Offset<rlbot.flat.Vector3Partial> EndVector3Partial(FlatBufferBuilder builder) {
    int o = builder.EndTable();
    return new Offset<rlbot.flat.Vector3Partial>(o);
  }
}


static public class Vector3PartialVerify
{
  static public bool Verify(Google.FlatBuffers.Verifier verifier, uint tablePos)
  {
    return verifier.VerifyTableStart(tablePos)
      && verifier.VerifyField(tablePos, 4 /*X*/, 4 /*rlbot.flat.Float*/, 4, false)
      && verifier.VerifyField(tablePos, 6 /*Y*/, 4 /*rlbot.flat.Float*/, 4, false)
      && verifier.VerifyField(tablePos, 8 /*Z*/, 4 /*rlbot.flat.Float*/, 4, false)
      && verifier.VerifyTableEnd(tablePos);
  }
}
public struct RotatorPartial : IFlatbufferObject
{
  private Table __p;
  public ByteBuffer ByteBuffer { get { return __p.bb; } }
  public static void ValidateVersion() { FlatBufferConstants.FLATBUFFERS_23_5_26(); }
  public static RotatorPartial GetRootAsRotatorPartial(ByteBuffer _bb) { return GetRootAsRotatorPartial(_bb, new RotatorPartial()); }
  public static RotatorPartial GetRootAsRotatorPartial(ByteBuffer _bb, RotatorPartial obj) { return (obj.__assign(_bb.GetInt(_bb.Position) + _bb.Position, _bb)); }
  public void __init(int _i, ByteBuffer _bb) { __p = new Table(_i, _bb); }
  public RotatorPartial __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }

  public rlbot.flat.Float? Pitch { get { int o = __p.__offset(4); return o != 0 ? (rlbot.flat.Float?)(new rlbot.flat.Float()).__assign(o + __p.bb_pos, __p.bb) : null; } }
  public rlbot.flat.Float? Yaw { get { int o = __p.__offset(6); return o != 0 ? (rlbot.flat.Float?)(new rlbot.flat.Float()).__assign(o + __p.bb_pos, __p.bb) : null; } }
  public rlbot.flat.Float? Roll { get { int o = __p.__offset(8); return o != 0 ? (rlbot.flat.Float?)(new rlbot.flat.Float()).__assign(o + __p.bb_pos, __p.bb) : null; } }

  public static void StartRotatorPartial(FlatBufferBuilder builder) { builder.StartTable(3); }
  public static void AddPitch(FlatBufferBuilder builder, Offset<rlbot.flat.Float> pitchOffset) { builder.AddStruct(0, pitchOffset.Value, 0); }
  public static void AddYaw(FlatBufferBuilder builder, Offset<rlbot.flat.Float> yawOffset) { builder.AddStruct(1, yawOffset.Value, 0); }
  public static void AddRoll(FlatBufferBuilder builder, Offset<rlbot.flat.Float> rollOffset) { builder.AddStruct(2, rollOffset.Value, 0); }
  public static Offset<rlbot.flat.RotatorPartial> EndRotatorPartial(FlatBufferBuilder builder) {
    int o = builder.EndTable();
    return new Offset<rlbot.flat.RotatorPartial>(o);
  }
}


static public class RotatorPartialVerify
{
  static public bool Verify(Google.FlatBuffers.Verifier verifier, uint tablePos)
  {
    return verifier.VerifyTableStart(tablePos)
      && verifier.VerifyField(tablePos, 4 /*Pitch*/, 4 /*rlbot.flat.Float*/, 4, false)
      && verifier.VerifyField(tablePos, 6 /*Yaw*/, 4 /*rlbot.flat.Float*/, 4, false)
      && verifier.VerifyField(tablePos, 8 /*Roll*/, 4 /*rlbot.flat.Float*/, 4, false)
      && verifier.VerifyTableEnd(tablePos);
  }
}
public struct DesiredPhysics : IFlatbufferObject
{
  private Table __p;
  public ByteBuffer ByteBuffer { get { return __p.bb; } }
  public static void ValidateVersion() { FlatBufferConstants.FLATBUFFERS_23_5_26(); }
  public static DesiredPhysics GetRootAsDesiredPhysics(ByteBuffer _bb) { return GetRootAsDesiredPhysics(_bb, new DesiredPhysics()); }
  public static DesiredPhysics GetRootAsDesiredPhysics(ByteBuffer _bb, DesiredPhysics obj) { return (obj.__assign(_bb.GetInt(_bb.Position) + _bb.Position, _bb)); }
  public void __init(int _i, ByteBuffer _bb) { __p = new Table(_i, _bb); }
  public DesiredPhysics __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }

  public rlbot.flat.Vector3Partial? Location { get { int o = __p.__offset(4); return o != 0 ? (rlbot.flat.Vector3Partial?)(new rlbot.flat.Vector3Partial()).__assign(__p.__indirect(o + __p.bb_pos), __p.bb) : null; } }
  public rlbot.flat.RotatorPartial? Rotation { get { int o = __p.__offset(6); return o != 0 ? (rlbot.flat.RotatorPartial?)(new rlbot.flat.RotatorPartial()).__assign(__p.__indirect(o + __p.bb_pos), __p.bb) : null; } }
  public rlbot.flat.Vector3Partial? Velocity { get { int o = __p.__offset(8); return o != 0 ? (rlbot.flat.Vector3Partial?)(new rlbot.flat.Vector3Partial()).__assign(__p.__indirect(o + __p.bb_pos), __p.bb) : null; } }
  public rlbot.flat.Vector3Partial? AngularVelocity { get { int o = __p.__offset(10); return o != 0 ? (rlbot.flat.Vector3Partial?)(new rlbot.flat.Vector3Partial()).__assign(__p.__indirect(o + __p.bb_pos), __p.bb) : null; } }

  public static Offset<rlbot.flat.DesiredPhysics> CreateDesiredPhysics(FlatBufferBuilder builder,
      Offset<rlbot.flat.Vector3Partial> locationOffset = default(Offset<rlbot.flat.Vector3Partial>),
      Offset<rlbot.flat.RotatorPartial> rotationOffset = default(Offset<rlbot.flat.RotatorPartial>),
      Offset<rlbot.flat.Vector3Partial> velocityOffset = default(Offset<rlbot.flat.Vector3Partial>),
      Offset<rlbot.flat.Vector3Partial> angularVelocityOffset = default(Offset<rlbot.flat.Vector3Partial>)) {
    builder.StartTable(4);
    DesiredPhysics.AddAngularVelocity(builder, angularVelocityOffset);
    DesiredPhysics.AddVelocity(builder, velocityOffset);
    DesiredPhysics.AddRotation(builder, rotationOffset);
    DesiredPhysics.AddLocation(builder, locationOffset);
    return DesiredPhysics.EndDesiredPhysics(builder);
  }

  public static void StartDesiredPhysics(FlatBufferBuilder builder) { builder.StartTable(4); }
  public static void AddLocation(FlatBufferBuilder builder, Offset<rlbot.flat.Vector3Partial> locationOffset) { builder.AddOffset(0, locationOffset.Value, 0); }
  public static void AddRotation(FlatBufferBuilder builder, Offset<rlbot.flat.RotatorPartial> rotationOffset) { builder.AddOffset(1, rotationOffset.Value, 0); }
  public static void AddVelocity(FlatBufferBuilder builder, Offset<rlbot.flat.Vector3Partial> velocityOffset) { builder.AddOffset(2, velocityOffset.Value, 0); }
  public static void AddAngularVelocity(FlatBufferBuilder builder, Offset<rlbot.flat.Vector3Partial> angularVelocityOffset) { builder.AddOffset(3, angularVelocityOffset.Value, 0); }
  public static Offset<rlbot.flat.DesiredPhysics> EndDesiredPhysics(FlatBufferBuilder builder) {
    int o = builder.EndTable();
    return new Offset<rlbot.flat.DesiredPhysics>(o);
  }
}


static public class DesiredPhysicsVerify
{
  static public bool Verify(Google.FlatBuffers.Verifier verifier, uint tablePos)
  {
    return verifier.VerifyTableStart(tablePos)
      && verifier.VerifyTable(tablePos, 4 /*Location*/, rlbot.flat.Vector3PartialVerify.Verify, false)
      && verifier.VerifyTable(tablePos, 6 /*Rotation*/, rlbot.flat.RotatorPartialVerify.Verify, false)
      && verifier.VerifyTable(tablePos, 8 /*Velocity*/, rlbot.flat.Vector3PartialVerify.Verify, false)
      && verifier.VerifyTable(tablePos, 10 /*AngularVelocity*/, rlbot.flat.Vector3PartialVerify.Verify, false)
      && verifier.VerifyTableEnd(tablePos);
  }
}
public struct DesiredBallState : IFlatbufferObject
{
  private Table __p;
  public ByteBuffer ByteBuffer { get { return __p.bb; } }
  public static void ValidateVersion() { FlatBufferConstants.FLATBUFFERS_23_5_26(); }
  public static DesiredBallState GetRootAsDesiredBallState(ByteBuffer _bb) { return GetRootAsDesiredBallState(_bb, new DesiredBallState()); }
  public static DesiredBallState GetRootAsDesiredBallState(ByteBuffer _bb, DesiredBallState obj) { return (obj.__assign(_bb.GetInt(_bb.Position) + _bb.Position, _bb)); }
  public void __init(int _i, ByteBuffer _bb) { __p = new Table(_i, _bb); }
  public DesiredBallState __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }

  public rlbot.flat.DesiredPhysics? Physics { get { int o = __p.__offset(4); return o != 0 ? (rlbot.flat.DesiredPhysics?)(new rlbot.flat.DesiredPhysics()).__assign(__p.__indirect(o + __p.bb_pos), __p.bb) : null; } }

  public static Offset<rlbot.flat.DesiredBallState> CreateDesiredBallState(FlatBufferBuilder builder,
      Offset<rlbot.flat.DesiredPhysics> physicsOffset = default(Offset<rlbot.flat.DesiredPhysics>)) {
    builder.StartTable(1);
    DesiredBallState.AddPhysics(builder, physicsOffset);
    return DesiredBallState.EndDesiredBallState(builder);
  }

  public static void StartDesiredBallState(FlatBufferBuilder builder) { builder.StartTable(1); }
  public static void AddPhysics(FlatBufferBuilder builder, Offset<rlbot.flat.DesiredPhysics> physicsOffset) { builder.AddOffset(0, physicsOffset.Value, 0); }
  public static Offset<rlbot.flat.DesiredBallState> EndDesiredBallState(FlatBufferBuilder builder) {
    int o = builder.EndTable();
    return new Offset<rlbot.flat.DesiredBallState>(o);
  }
}


static public class DesiredBallStateVerify
{
  static public bool Verify(Google.FlatBuffers.Verifier verifier, uint tablePos)
  {
    return verifier.VerifyTableStart(tablePos)
      && verifier.VerifyTable(tablePos, 4 /*Physics*/, rlbot.flat.DesiredPhysicsVerify.Verify, false)
      && verifier.VerifyTableEnd(tablePos);
  }
}
public struct DesiredCarState : IFlatbufferObject
{
  private Table __p;
  public ByteBuffer ByteBuffer { get { return __p.bb; } }
  public static void ValidateVersion() { FlatBufferConstants.FLATBUFFERS_23_5_26(); }
  public static DesiredCarState GetRootAsDesiredCarState(ByteBuffer _bb) { return GetRootAsDesiredCarState(_bb, new DesiredCarState()); }
  public static DesiredCarState GetRootAsDesiredCarState(ByteBuffer _bb, DesiredCarState obj) { return (obj.__assign(_bb.GetInt(_bb.Position) + _bb.Position, _bb)); }
  public void __init(int _i, ByteBuffer _bb) { __p = new Table(_i, _bb); }
  public DesiredCarState __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }

  public rlbot.flat.DesiredPhysics? Physics { get { int o = __p.__offset(4); return o != 0 ? (rlbot.flat.DesiredPhysics?)(new rlbot.flat.DesiredPhysics()).__assign(__p.__indirect(o + __p.bb_pos), __p.bb) : null; } }
  public rlbot.flat.Float? BoostAmount { get { int o = __p.__offset(6); return o != 0 ? (rlbot.flat.Float?)(new rlbot.flat.Float()).__assign(o + __p.bb_pos, __p.bb) : null; } }
  public rlbot.flat.Bool? Jumped { get { int o = __p.__offset(8); return o != 0 ? (rlbot.flat.Bool?)(new rlbot.flat.Bool()).__assign(o + __p.bb_pos, __p.bb) : null; } }
  public rlbot.flat.Bool? DoubleJumped { get { int o = __p.__offset(10); return o != 0 ? (rlbot.flat.Bool?)(new rlbot.flat.Bool()).__assign(o + __p.bb_pos, __p.bb) : null; } }

  public static void StartDesiredCarState(FlatBufferBuilder builder) { builder.StartTable(4); }
  public static void AddPhysics(FlatBufferBuilder builder, Offset<rlbot.flat.DesiredPhysics> physicsOffset) { builder.AddOffset(0, physicsOffset.Value, 0); }
  public static void AddBoostAmount(FlatBufferBuilder builder, Offset<rlbot.flat.Float> boostAmountOffset) { builder.AddStruct(1, boostAmountOffset.Value, 0); }
  public static void AddJumped(FlatBufferBuilder builder, Offset<rlbot.flat.Bool> jumpedOffset) { builder.AddStruct(2, jumpedOffset.Value, 0); }
  public static void AddDoubleJumped(FlatBufferBuilder builder, Offset<rlbot.flat.Bool> doubleJumpedOffset) { builder.AddStruct(3, doubleJumpedOffset.Value, 0); }
  public static Offset<rlbot.flat.DesiredCarState> EndDesiredCarState(FlatBufferBuilder builder) {
    int o = builder.EndTable();
    return new Offset<rlbot.flat.DesiredCarState>(o);
  }
}


static public class DesiredCarStateVerify
{
  static public bool Verify(Google.FlatBuffers.Verifier verifier, uint tablePos)
  {
    return verifier.VerifyTableStart(tablePos)
      && verifier.VerifyTable(tablePos, 4 /*Physics*/, rlbot.flat.DesiredPhysicsVerify.Verify, false)
      && verifier.VerifyField(tablePos, 6 /*BoostAmount*/, 4 /*rlbot.flat.Float*/, 4, false)
      && verifier.VerifyField(tablePos, 8 /*Jumped*/, 1 /*rlbot.flat.Bool*/, 1, false)
      && verifier.VerifyField(tablePos, 10 /*DoubleJumped*/, 1 /*rlbot.flat.Bool*/, 1, false)
      && verifier.VerifyTableEnd(tablePos);
  }
}
public struct DesiredBoostState : IFlatbufferObject
{
  private Table __p;
  public ByteBuffer ByteBuffer { get { return __p.bb; } }
  public static void ValidateVersion() { FlatBufferConstants.FLATBUFFERS_23_5_26(); }
  public static DesiredBoostState GetRootAsDesiredBoostState(ByteBuffer _bb) { return GetRootAsDesiredBoostState(_bb, new DesiredBoostState()); }
  public static DesiredBoostState GetRootAsDesiredBoostState(ByteBuffer _bb, DesiredBoostState obj) { return (obj.__assign(_bb.GetInt(_bb.Position) + _bb.Position, _bb)); }
  public void __init(int _i, ByteBuffer _bb) { __p = new Table(_i, _bb); }
  public DesiredBoostState __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }

  public rlbot.flat.Float? RespawnTime { get { int o = __p.__offset(4); return o != 0 ? (rlbot.flat.Float?)(new rlbot.flat.Float()).__assign(o + __p.bb_pos, __p.bb) : null; } }

  public static void StartDesiredBoostState(FlatBufferBuilder builder) { builder.StartTable(1); }
  public static void AddRespawnTime(FlatBufferBuilder builder, Offset<rlbot.flat.Float> respawnTimeOffset) { builder.AddStruct(0, respawnTimeOffset.Value, 0); }
  public static Offset<rlbot.flat.DesiredBoostState> EndDesiredBoostState(FlatBufferBuilder builder) {
    int o = builder.EndTable();
    return new Offset<rlbot.flat.DesiredBoostState>(o);
  }
}


static public class DesiredBoostStateVerify
{
  static public bool Verify(Google.FlatBuffers.Verifier verifier, uint tablePos)
  {
    return verifier.VerifyTableStart(tablePos)
      && verifier.VerifyField(tablePos, 4 /*RespawnTime*/, 4 /*rlbot.flat.Float*/, 4, false)
      && verifier.VerifyTableEnd(tablePos);
  }
}
public struct DesiredGameInfoState : IFlatbufferObject
{
  private Table __p;
  public ByteBuffer ByteBuffer { get { return __p.bb; } }
  public static void ValidateVersion() { FlatBufferConstants.FLATBUFFERS_23_5_26(); }
  public static DesiredGameInfoState GetRootAsDesiredGameInfoState(ByteBuffer _bb) { return GetRootAsDesiredGameInfoState(_bb, new DesiredGameInfoState()); }
  public static DesiredGameInfoState GetRootAsDesiredGameInfoState(ByteBuffer _bb, DesiredGameInfoState obj) { return (obj.__assign(_bb.GetInt(_bb.Position) + _bb.Position, _bb)); }
  public void __init(int _i, ByteBuffer _bb) { __p = new Table(_i, _bb); }
  public DesiredGameInfoState __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }

  public rlbot.flat.Float? WorldGravityZ { get { int o = __p.__offset(4); return o != 0 ? (rlbot.flat.Float?)(new rlbot.flat.Float()).__assign(o + __p.bb_pos, __p.bb) : null; } }
  public rlbot.flat.Float? GameSpeed { get { int o = __p.__offset(6); return o != 0 ? (rlbot.flat.Float?)(new rlbot.flat.Float()).__assign(o + __p.bb_pos, __p.bb) : null; } }
  public rlbot.flat.Bool? Paused { get { int o = __p.__offset(8); return o != 0 ? (rlbot.flat.Bool?)(new rlbot.flat.Bool()).__assign(o + __p.bb_pos, __p.bb) : null; } }
  public rlbot.flat.Bool? EndMatch { get { int o = __p.__offset(10); return o != 0 ? (rlbot.flat.Bool?)(new rlbot.flat.Bool()).__assign(o + __p.bb_pos, __p.bb) : null; } }

  public static void StartDesiredGameInfoState(FlatBufferBuilder builder) { builder.StartTable(4); }
  public static void AddWorldGravityZ(FlatBufferBuilder builder, Offset<rlbot.flat.Float> worldGravityZOffset) { builder.AddStruct(0, worldGravityZOffset.Value, 0); }
  public static void AddGameSpeed(FlatBufferBuilder builder, Offset<rlbot.flat.Float> gameSpeedOffset) { builder.AddStruct(1, gameSpeedOffset.Value, 0); }
  public static void AddPaused(FlatBufferBuilder builder, Offset<rlbot.flat.Bool> pausedOffset) { builder.AddStruct(2, pausedOffset.Value, 0); }
  public static void AddEndMatch(FlatBufferBuilder builder, Offset<rlbot.flat.Bool> endMatchOffset) { builder.AddStruct(3, endMatchOffset.Value, 0); }
  public static Offset<rlbot.flat.DesiredGameInfoState> EndDesiredGameInfoState(FlatBufferBuilder builder) {
    int o = builder.EndTable();
    return new Offset<rlbot.flat.DesiredGameInfoState>(o);
  }
}


static public class DesiredGameInfoStateVerify
{
  static public bool Verify(Google.FlatBuffers.Verifier verifier, uint tablePos)
  {
    return verifier.VerifyTableStart(tablePos)
      && verifier.VerifyField(tablePos, 4 /*WorldGravityZ*/, 4 /*rlbot.flat.Float*/, 4, false)
      && verifier.VerifyField(tablePos, 6 /*GameSpeed*/, 4 /*rlbot.flat.Float*/, 4, false)
      && verifier.VerifyField(tablePos, 8 /*Paused*/, 1 /*rlbot.flat.Bool*/, 1, false)
      && verifier.VerifyField(tablePos, 10 /*EndMatch*/, 1 /*rlbot.flat.Bool*/, 1, false)
      && verifier.VerifyTableEnd(tablePos);
  }
}
/// A console command which we will try to execute inside Rocket League.
/// See https://github.com/RLBot/RLBot/wiki/Console-Commands for a list of known commands.
public struct ConsoleCommand : IFlatbufferObject
{
  private Table __p;
  public ByteBuffer ByteBuffer { get { return __p.bb; } }
  public static void ValidateVersion() { FlatBufferConstants.FLATBUFFERS_23_5_26(); }
  public static ConsoleCommand GetRootAsConsoleCommand(ByteBuffer _bb) { return GetRootAsConsoleCommand(_bb, new ConsoleCommand()); }
  public static ConsoleCommand GetRootAsConsoleCommand(ByteBuffer _bb, ConsoleCommand obj) { return (obj.__assign(_bb.GetInt(_bb.Position) + _bb.Position, _bb)); }
  public void __init(int _i, ByteBuffer _bb) { __p = new Table(_i, _bb); }
  public ConsoleCommand __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }

  public string Command { get { int o = __p.__offset(4); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetCommandBytes() { return __p.__vector_as_span<byte>(4, 1); }
#else
  public ArraySegment<byte>? GetCommandBytes() { return __p.__vector_as_arraysegment(4); }
#endif
  public byte[] GetCommandArray() { return __p.__vector_as_array<byte>(4); }

  public static Offset<rlbot.flat.ConsoleCommand> CreateConsoleCommand(FlatBufferBuilder builder,
      StringOffset commandOffset = default(StringOffset)) {
    builder.StartTable(1);
    ConsoleCommand.AddCommand(builder, commandOffset);
    return ConsoleCommand.EndConsoleCommand(builder);
  }

  public static void StartConsoleCommand(FlatBufferBuilder builder) { builder.StartTable(1); }
  public static void AddCommand(FlatBufferBuilder builder, StringOffset commandOffset) { builder.AddOffset(0, commandOffset.Value, 0); }
  public static Offset<rlbot.flat.ConsoleCommand> EndConsoleCommand(FlatBufferBuilder builder) {
    int o = builder.EndTable();
    return new Offset<rlbot.flat.ConsoleCommand>(o);
  }
}


static public class ConsoleCommandVerify
{
  static public bool Verify(Google.FlatBuffers.Verifier verifier, uint tablePos)
  {
    return verifier.VerifyTableStart(tablePos)
      && verifier.VerifyString(tablePos, 4 /*Command*/, false)
      && verifier.VerifyTableEnd(tablePos);
  }
}
public struct DesiredGameState : IFlatbufferObject
{
  private Table __p;
  public ByteBuffer ByteBuffer { get { return __p.bb; } }
  public static void ValidateVersion() { FlatBufferConstants.FLATBUFFERS_23_5_26(); }
  public static DesiredGameState GetRootAsDesiredGameState(ByteBuffer _bb) { return GetRootAsDesiredGameState(_bb, new DesiredGameState()); }
  public static DesiredGameState GetRootAsDesiredGameState(ByteBuffer _bb, DesiredGameState obj) { return (obj.__assign(_bb.GetInt(_bb.Position) + _bb.Position, _bb)); }
  public void __init(int _i, ByteBuffer _bb) { __p = new Table(_i, _bb); }
  public DesiredGameState __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }

  public rlbot.flat.DesiredBallState? BallState { get { int o = __p.__offset(4); return o != 0 ? (rlbot.flat.DesiredBallState?)(new rlbot.flat.DesiredBallState()).__assign(__p.__indirect(o + __p.bb_pos), __p.bb) : null; } }
  public rlbot.flat.DesiredCarState? CarStates(int j) { int o = __p.__offset(6); return o != 0 ? (rlbot.flat.DesiredCarState?)(new rlbot.flat.DesiredCarState()).__assign(__p.__indirect(__p.__vector(o) + j * 4), __p.bb) : null; }
  public int CarStatesLength { get { int o = __p.__offset(6); return o != 0 ? __p.__vector_len(o) : 0; } }
  public rlbot.flat.DesiredBoostState? BoostStates(int j) { int o = __p.__offset(8); return o != 0 ? (rlbot.flat.DesiredBoostState?)(new rlbot.flat.DesiredBoostState()).__assign(__p.__indirect(__p.__vector(o) + j * 4), __p.bb) : null; }
  public int BoostStatesLength { get { int o = __p.__offset(8); return o != 0 ? __p.__vector_len(o) : 0; } }
  public rlbot.flat.DesiredGameInfoState? GameInfoState { get { int o = __p.__offset(10); return o != 0 ? (rlbot.flat.DesiredGameInfoState?)(new rlbot.flat.DesiredGameInfoState()).__assign(__p.__indirect(o + __p.bb_pos), __p.bb) : null; } }
  public rlbot.flat.ConsoleCommand? ConsoleCommands(int j) { int o = __p.__offset(12); return o != 0 ? (rlbot.flat.ConsoleCommand?)(new rlbot.flat.ConsoleCommand()).__assign(__p.__indirect(__p.__vector(o) + j * 4), __p.bb) : null; }
  public int ConsoleCommandsLength { get { int o = __p.__offset(12); return o != 0 ? __p.__vector_len(o) : 0; } }

  public static Offset<rlbot.flat.DesiredGameState> CreateDesiredGameState(FlatBufferBuilder builder,
      Offset<rlbot.flat.DesiredBallState> ballStateOffset = default(Offset<rlbot.flat.DesiredBallState>),
      VectorOffset carStatesOffset = default(VectorOffset),
      VectorOffset boostStatesOffset = default(VectorOffset),
      Offset<rlbot.flat.DesiredGameInfoState> gameInfoStateOffset = default(Offset<rlbot.flat.DesiredGameInfoState>),
      VectorOffset consoleCommandsOffset = default(VectorOffset)) {
    builder.StartTable(5);
    DesiredGameState.AddConsoleCommands(builder, consoleCommandsOffset);
    DesiredGameState.AddGameInfoState(builder, gameInfoStateOffset);
    DesiredGameState.AddBoostStates(builder, boostStatesOffset);
    DesiredGameState.AddCarStates(builder, carStatesOffset);
    DesiredGameState.AddBallState(builder, ballStateOffset);
    return DesiredGameState.EndDesiredGameState(builder);
  }

  public static void StartDesiredGameState(FlatBufferBuilder builder) { builder.StartTable(5); }
  public static void AddBallState(FlatBufferBuilder builder, Offset<rlbot.flat.DesiredBallState> ballStateOffset) { builder.AddOffset(0, ballStateOffset.Value, 0); }
  public static void AddCarStates(FlatBufferBuilder builder, VectorOffset carStatesOffset) { builder.AddOffset(1, carStatesOffset.Value, 0); }
  public static VectorOffset CreateCarStatesVector(FlatBufferBuilder builder, Offset<rlbot.flat.DesiredCarState>[] data) { builder.StartVector(4, data.Length, 4); for (int i = data.Length - 1; i >= 0; i--) builder.AddOffset(data[i].Value); return builder.EndVector(); }
  public static VectorOffset CreateCarStatesVectorBlock(FlatBufferBuilder builder, Offset<rlbot.flat.DesiredCarState>[] data) { builder.StartVector(4, data.Length, 4); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreateCarStatesVectorBlock(FlatBufferBuilder builder, ArraySegment<Offset<rlbot.flat.DesiredCarState>> data) { builder.StartVector(4, data.Count, 4); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreateCarStatesVectorBlock(FlatBufferBuilder builder, IntPtr dataPtr, int sizeInBytes) { builder.StartVector(1, sizeInBytes, 1); builder.Add<Offset<rlbot.flat.DesiredCarState>>(dataPtr, sizeInBytes); return builder.EndVector(); }
  public static void StartCarStatesVector(FlatBufferBuilder builder, int numElems) { builder.StartVector(4, numElems, 4); }
  public static void AddBoostStates(FlatBufferBuilder builder, VectorOffset boostStatesOffset) { builder.AddOffset(2, boostStatesOffset.Value, 0); }
  public static VectorOffset CreateBoostStatesVector(FlatBufferBuilder builder, Offset<rlbot.flat.DesiredBoostState>[] data) { builder.StartVector(4, data.Length, 4); for (int i = data.Length - 1; i >= 0; i--) builder.AddOffset(data[i].Value); return builder.EndVector(); }
  public static VectorOffset CreateBoostStatesVectorBlock(FlatBufferBuilder builder, Offset<rlbot.flat.DesiredBoostState>[] data) { builder.StartVector(4, data.Length, 4); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreateBoostStatesVectorBlock(FlatBufferBuilder builder, ArraySegment<Offset<rlbot.flat.DesiredBoostState>> data) { builder.StartVector(4, data.Count, 4); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreateBoostStatesVectorBlock(FlatBufferBuilder builder, IntPtr dataPtr, int sizeInBytes) { builder.StartVector(1, sizeInBytes, 1); builder.Add<Offset<rlbot.flat.DesiredBoostState>>(dataPtr, sizeInBytes); return builder.EndVector(); }
  public static void StartBoostStatesVector(FlatBufferBuilder builder, int numElems) { builder.StartVector(4, numElems, 4); }
  public static void AddGameInfoState(FlatBufferBuilder builder, Offset<rlbot.flat.DesiredGameInfoState> gameInfoStateOffset) { builder.AddOffset(3, gameInfoStateOffset.Value, 0); }
  public static void AddConsoleCommands(FlatBufferBuilder builder, VectorOffset consoleCommandsOffset) { builder.AddOffset(4, consoleCommandsOffset.Value, 0); }
  public static VectorOffset CreateConsoleCommandsVector(FlatBufferBuilder builder, Offset<rlbot.flat.ConsoleCommand>[] data) { builder.StartVector(4, data.Length, 4); for (int i = data.Length - 1; i >= 0; i--) builder.AddOffset(data[i].Value); return builder.EndVector(); }
  public static VectorOffset CreateConsoleCommandsVectorBlock(FlatBufferBuilder builder, Offset<rlbot.flat.ConsoleCommand>[] data) { builder.StartVector(4, data.Length, 4); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreateConsoleCommandsVectorBlock(FlatBufferBuilder builder, ArraySegment<Offset<rlbot.flat.ConsoleCommand>> data) { builder.StartVector(4, data.Count, 4); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreateConsoleCommandsVectorBlock(FlatBufferBuilder builder, IntPtr dataPtr, int sizeInBytes) { builder.StartVector(1, sizeInBytes, 1); builder.Add<Offset<rlbot.flat.ConsoleCommand>>(dataPtr, sizeInBytes); return builder.EndVector(); }
  public static void StartConsoleCommandsVector(FlatBufferBuilder builder, int numElems) { builder.StartVector(4, numElems, 4); }
  public static Offset<rlbot.flat.DesiredGameState> EndDesiredGameState(FlatBufferBuilder builder) {
    int o = builder.EndTable();
    return new Offset<rlbot.flat.DesiredGameState>(o);
  }
}


static public class DesiredGameStateVerify
{
  static public bool Verify(Google.FlatBuffers.Verifier verifier, uint tablePos)
  {
    return verifier.VerifyTableStart(tablePos)
      && verifier.VerifyTable(tablePos, 4 /*BallState*/, rlbot.flat.DesiredBallStateVerify.Verify, false)
      && verifier.VerifyVectorOfTables(tablePos, 6 /*CarStates*/, rlbot.flat.DesiredCarStateVerify.Verify, false)
      && verifier.VerifyVectorOfTables(tablePos, 8 /*BoostStates*/, rlbot.flat.DesiredBoostStateVerify.Verify, false)
      && verifier.VerifyTable(tablePos, 10 /*GameInfoState*/, rlbot.flat.DesiredGameInfoStateVerify.Verify, false)
      && verifier.VerifyVectorOfTables(tablePos, 12 /*ConsoleCommands*/, rlbot.flat.ConsoleCommandVerify.Verify, false)
      && verifier.VerifyTableEnd(tablePos);
  }
}
public struct Color : IFlatbufferObject
{
  private Table __p;
  public ByteBuffer ByteBuffer { get { return __p.bb; } }
  public static void ValidateVersion() { FlatBufferConstants.FLATBUFFERS_23_5_26(); }
  public static Color GetRootAsColor(ByteBuffer _bb) { return GetRootAsColor(_bb, new Color()); }
  public static Color GetRootAsColor(ByteBuffer _bb, Color obj) { return (obj.__assign(_bb.GetInt(_bb.Position) + _bb.Position, _bb)); }
  public void __init(int _i, ByteBuffer _bb) { __p = new Table(_i, _bb); }
  public Color __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }

  public byte A { get { int o = __p.__offset(4); return o != 0 ? __p.bb.Get(o + __p.bb_pos) : (byte)0; } }
  public byte R { get { int o = __p.__offset(6); return o != 0 ? __p.bb.Get(o + __p.bb_pos) : (byte)0; } }
  public byte G { get { int o = __p.__offset(8); return o != 0 ? __p.bb.Get(o + __p.bb_pos) : (byte)0; } }
  public byte B { get { int o = __p.__offset(10); return o != 0 ? __p.bb.Get(o + __p.bb_pos) : (byte)0; } }

  public static Offset<rlbot.flat.Color> CreateColor(FlatBufferBuilder builder,
      byte a = 0,
      byte r = 0,
      byte g = 0,
      byte b = 0) {
    builder.StartTable(4);
    Color.AddB(builder, b);
    Color.AddG(builder, g);
    Color.AddR(builder, r);
    Color.AddA(builder, a);
    return Color.EndColor(builder);
  }

  public static void StartColor(FlatBufferBuilder builder) { builder.StartTable(4); }
  public static void AddA(FlatBufferBuilder builder, byte a) { builder.AddByte(0, a, 0); }
  public static void AddR(FlatBufferBuilder builder, byte r) { builder.AddByte(1, r, 0); }
  public static void AddG(FlatBufferBuilder builder, byte g) { builder.AddByte(2, g, 0); }
  public static void AddB(FlatBufferBuilder builder, byte b) { builder.AddByte(3, b, 0); }
  public static Offset<rlbot.flat.Color> EndColor(FlatBufferBuilder builder) {
    int o = builder.EndTable();
    return new Offset<rlbot.flat.Color>(o);
  }
}


static public class ColorVerify
{
  static public bool Verify(Google.FlatBuffers.Verifier verifier, uint tablePos)
  {
    return verifier.VerifyTableStart(tablePos)
      && verifier.VerifyField(tablePos, 4 /*A*/, 1 /*byte*/, 1, false)
      && verifier.VerifyField(tablePos, 6 /*R*/, 1 /*byte*/, 1, false)
      && verifier.VerifyField(tablePos, 8 /*G*/, 1 /*byte*/, 1, false)
      && verifier.VerifyField(tablePos, 10 /*B*/, 1 /*byte*/, 1, false)
      && verifier.VerifyTableEnd(tablePos);
  }
}
public struct RenderMessage : IFlatbufferObject
{
  private Table __p;
  public ByteBuffer ByteBuffer { get { return __p.bb; } }
  public static void ValidateVersion() { FlatBufferConstants.FLATBUFFERS_23_5_26(); }
  public static RenderMessage GetRootAsRenderMessage(ByteBuffer _bb) { return GetRootAsRenderMessage(_bb, new RenderMessage()); }
  public static RenderMessage GetRootAsRenderMessage(ByteBuffer _bb, RenderMessage obj) { return (obj.__assign(_bb.GetInt(_bb.Position) + _bb.Position, _bb)); }
  public void __init(int _i, ByteBuffer _bb) { __p = new Table(_i, _bb); }
  public RenderMessage __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }

  public rlbot.flat.RenderType RenderType { get { int o = __p.__offset(4); return o != 0 ? (rlbot.flat.RenderType)__p.bb.GetSbyte(o + __p.bb_pos) : rlbot.flat.RenderType.DrawLine2D; } }
  public rlbot.flat.Color? Color { get { int o = __p.__offset(6); return o != 0 ? (rlbot.flat.Color?)(new rlbot.flat.Color()).__assign(__p.__indirect(o + __p.bb_pos), __p.bb) : null; } }
  /// For 2d renders this only grabs x and y
  public rlbot.flat.Vector3? Start { get { int o = __p.__offset(8); return o != 0 ? (rlbot.flat.Vector3?)(new rlbot.flat.Vector3()).__assign(o + __p.bb_pos, __p.bb) : null; } }
  /// For 2d renders this only grabs x and y
  public rlbot.flat.Vector3? End { get { int o = __p.__offset(10); return o != 0 ? (rlbot.flat.Vector3?)(new rlbot.flat.Vector3()).__assign(o + __p.bb_pos, __p.bb) : null; } }
  /// Scales the x size of the text/rectangle, is used for rectangles assuming an initial value of 1
  public int ScaleX { get { int o = __p.__offset(12); return o != 0 ? __p.bb.GetInt(o + __p.bb_pos) : (int)1; } }
  /// Scales the y size of the text/rectangle, is used for rectangles assuming an initial value of 1
  public int ScaleY { get { int o = __p.__offset(14); return o != 0 ? __p.bb.GetInt(o + __p.bb_pos) : (int)1; } }
  public string Text { get { int o = __p.__offset(16); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetTextBytes() { return __p.__vector_as_span<byte>(16, 1); }
#else
  public ArraySegment<byte>? GetTextBytes() { return __p.__vector_as_arraysegment(16); }
#endif
  public byte[] GetTextArray() { return __p.__vector_as_array<byte>(16); }
  /// Rectangles can be filled or just outlines.
  public bool IsFilled { get { int o = __p.__offset(18); return o != 0 ? 0!=__p.bb.Get(o + __p.bb_pos) : (bool)false; } }

  public static void StartRenderMessage(FlatBufferBuilder builder) { builder.StartTable(8); }
  public static void AddRenderType(FlatBufferBuilder builder, rlbot.flat.RenderType renderType) { builder.AddSbyte(0, (sbyte)renderType, 1); }
  public static void AddColor(FlatBufferBuilder builder, Offset<rlbot.flat.Color> colorOffset) { builder.AddOffset(1, colorOffset.Value, 0); }
  public static void AddStart(FlatBufferBuilder builder, Offset<rlbot.flat.Vector3> startOffset) { builder.AddStruct(2, startOffset.Value, 0); }
  public static void AddEnd(FlatBufferBuilder builder, Offset<rlbot.flat.Vector3> endOffset) { builder.AddStruct(3, endOffset.Value, 0); }
  public static void AddScaleX(FlatBufferBuilder builder, int scaleX) { builder.AddInt(4, scaleX, 1); }
  public static void AddScaleY(FlatBufferBuilder builder, int scaleY) { builder.AddInt(5, scaleY, 1); }
  public static void AddText(FlatBufferBuilder builder, StringOffset textOffset) { builder.AddOffset(6, textOffset.Value, 0); }
  public static void AddIsFilled(FlatBufferBuilder builder, bool isFilled) { builder.AddBool(7, isFilled, false); }
  public static Offset<rlbot.flat.RenderMessage> EndRenderMessage(FlatBufferBuilder builder) {
    int o = builder.EndTable();
    return new Offset<rlbot.flat.RenderMessage>(o);
  }
}


static public class RenderMessageVerify
{
  static public bool Verify(Google.FlatBuffers.Verifier verifier, uint tablePos)
  {
    return verifier.VerifyTableStart(tablePos)
      && verifier.VerifyField(tablePos, 4 /*RenderType*/, 1 /*rlbot.flat.RenderType*/, 1, false)
      && verifier.VerifyTable(tablePos, 6 /*Color*/, rlbot.flat.ColorVerify.Verify, false)
      && verifier.VerifyField(tablePos, 8 /*Start*/, 12 /*rlbot.flat.Vector3*/, 4, false)
      && verifier.VerifyField(tablePos, 10 /*End*/, 12 /*rlbot.flat.Vector3*/, 4, false)
      && verifier.VerifyField(tablePos, 12 /*ScaleX*/, 4 /*int*/, 4, false)
      && verifier.VerifyField(tablePos, 14 /*ScaleY*/, 4 /*int*/, 4, false)
      && verifier.VerifyString(tablePos, 16 /*Text*/, false)
      && verifier.VerifyField(tablePos, 18 /*IsFilled*/, 1 /*bool*/, 1, false)
      && verifier.VerifyTableEnd(tablePos);
  }
}
public struct RenderGroup : IFlatbufferObject
{
  private Table __p;
  public ByteBuffer ByteBuffer { get { return __p.bb; } }
  public static void ValidateVersion() { FlatBufferConstants.FLATBUFFERS_23_5_26(); }
  public static RenderGroup GetRootAsRenderGroup(ByteBuffer _bb) { return GetRootAsRenderGroup(_bb, new RenderGroup()); }
  public static RenderGroup GetRootAsRenderGroup(ByteBuffer _bb, RenderGroup obj) { return (obj.__assign(_bb.GetInt(_bb.Position) + _bb.Position, _bb)); }
  public void __init(int _i, ByteBuffer _bb) { __p = new Table(_i, _bb); }
  public RenderGroup __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }

  public rlbot.flat.RenderMessage? RenderMessages(int j) { int o = __p.__offset(4); return o != 0 ? (rlbot.flat.RenderMessage?)(new rlbot.flat.RenderMessage()).__assign(__p.__indirect(__p.__vector(o) + j * 4), __p.bb) : null; }
  public int RenderMessagesLength { get { int o = __p.__offset(4); return o != 0 ? __p.__vector_len(o) : 0; } }
  /// The id of the render group
  public int Id { get { int o = __p.__offset(6); return o != 0 ? __p.bb.GetInt(o + __p.bb_pos) : (int)0; } }

  public static Offset<rlbot.flat.RenderGroup> CreateRenderGroup(FlatBufferBuilder builder,
      VectorOffset renderMessagesOffset = default(VectorOffset),
      int id = 0) {
    builder.StartTable(2);
    RenderGroup.AddId(builder, id);
    RenderGroup.AddRenderMessages(builder, renderMessagesOffset);
    return RenderGroup.EndRenderGroup(builder);
  }

  public static void StartRenderGroup(FlatBufferBuilder builder) { builder.StartTable(2); }
  public static void AddRenderMessages(FlatBufferBuilder builder, VectorOffset renderMessagesOffset) { builder.AddOffset(0, renderMessagesOffset.Value, 0); }
  public static VectorOffset CreateRenderMessagesVector(FlatBufferBuilder builder, Offset<rlbot.flat.RenderMessage>[] data) { builder.StartVector(4, data.Length, 4); for (int i = data.Length - 1; i >= 0; i--) builder.AddOffset(data[i].Value); return builder.EndVector(); }
  public static VectorOffset CreateRenderMessagesVectorBlock(FlatBufferBuilder builder, Offset<rlbot.flat.RenderMessage>[] data) { builder.StartVector(4, data.Length, 4); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreateRenderMessagesVectorBlock(FlatBufferBuilder builder, ArraySegment<Offset<rlbot.flat.RenderMessage>> data) { builder.StartVector(4, data.Count, 4); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreateRenderMessagesVectorBlock(FlatBufferBuilder builder, IntPtr dataPtr, int sizeInBytes) { builder.StartVector(1, sizeInBytes, 1); builder.Add<Offset<rlbot.flat.RenderMessage>>(dataPtr, sizeInBytes); return builder.EndVector(); }
  public static void StartRenderMessagesVector(FlatBufferBuilder builder, int numElems) { builder.StartVector(4, numElems, 4); }
  public static void AddId(FlatBufferBuilder builder, int id) { builder.AddInt(1, id, 0); }
  public static Offset<rlbot.flat.RenderGroup> EndRenderGroup(FlatBufferBuilder builder) {
    int o = builder.EndTable();
    return new Offset<rlbot.flat.RenderGroup>(o);
  }
}


static public class RenderGroupVerify
{
  static public bool Verify(Google.FlatBuffers.Verifier verifier, uint tablePos)
  {
    return verifier.VerifyTableStart(tablePos)
      && verifier.VerifyVectorOfTables(tablePos, 4 /*RenderMessages*/, rlbot.flat.RenderMessageVerify.Verify, false)
      && verifier.VerifyField(tablePos, 6 /*Id*/, 4 /*int*/, 4, false)
      && verifier.VerifyTableEnd(tablePos);
  }
}
public struct QuickChat : IFlatbufferObject
{
  private Table __p;
  public ByteBuffer ByteBuffer { get { return __p.bb; } }
  public static void ValidateVersion() { FlatBufferConstants.FLATBUFFERS_23_5_26(); }
  public static QuickChat GetRootAsQuickChat(ByteBuffer _bb) { return GetRootAsQuickChat(_bb, new QuickChat()); }
  public static QuickChat GetRootAsQuickChat(ByteBuffer _bb, QuickChat obj) { return (obj.__assign(_bb.GetInt(_bb.Position) + _bb.Position, _bb)); }
  public static bool VerifyQuickChat(ByteBuffer _bb) {Google.FlatBuffers.Verifier verifier = new Google.FlatBuffers.Verifier(_bb); return verifier.VerifyBuffer("", false, QuickChatVerify.Verify); }
  public void __init(int _i, ByteBuffer _bb) { __p = new Table(_i, _bb); }
  public QuickChat __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }

  public rlbot.flat.QuickChatSelection QuickChatSelection { get { int o = __p.__offset(4); return o != 0 ? (rlbot.flat.QuickChatSelection)__p.bb.GetSbyte(o + __p.bb_pos) : rlbot.flat.QuickChatSelection.Information_IGotIt; } }
  /// The index of the player that sent the quick chat
  public int PlayerIndex { get { int o = __p.__offset(6); return o != 0 ? __p.bb.GetInt(o + __p.bb_pos) : (int)0; } }
  /// True if the chat is team only false if everyone can see it.
  public bool TeamOnly { get { int o = __p.__offset(8); return o != 0 ? 0!=__p.bb.Get(o + __p.bb_pos) : (bool)false; } }
  public int MessageIndex { get { int o = __p.__offset(10); return o != 0 ? __p.bb.GetInt(o + __p.bb_pos) : (int)0; } }
  public float TimeStamp { get { int o = __p.__offset(12); return o != 0 ? __p.bb.GetFloat(o + __p.bb_pos) : (float)0.0f; } }

  public static Offset<rlbot.flat.QuickChat> CreateQuickChat(FlatBufferBuilder builder,
      rlbot.flat.QuickChatSelection quickChatSelection = rlbot.flat.QuickChatSelection.Information_IGotIt,
      int playerIndex = 0,
      bool teamOnly = false,
      int messageIndex = 0,
      float timeStamp = 0.0f) {
    builder.StartTable(5);
    QuickChat.AddTimeStamp(builder, timeStamp);
    QuickChat.AddMessageIndex(builder, messageIndex);
    QuickChat.AddPlayerIndex(builder, playerIndex);
    QuickChat.AddTeamOnly(builder, teamOnly);
    QuickChat.AddQuickChatSelection(builder, quickChatSelection);
    return QuickChat.EndQuickChat(builder);
  }

  public static void StartQuickChat(FlatBufferBuilder builder) { builder.StartTable(5); }
  public static void AddQuickChatSelection(FlatBufferBuilder builder, rlbot.flat.QuickChatSelection quickChatSelection) { builder.AddSbyte(0, (sbyte)quickChatSelection, 0); }
  public static void AddPlayerIndex(FlatBufferBuilder builder, int playerIndex) { builder.AddInt(1, playerIndex, 0); }
  public static void AddTeamOnly(FlatBufferBuilder builder, bool teamOnly) { builder.AddBool(2, teamOnly, false); }
  public static void AddMessageIndex(FlatBufferBuilder builder, int messageIndex) { builder.AddInt(3, messageIndex, 0); }
  public static void AddTimeStamp(FlatBufferBuilder builder, float timeStamp) { builder.AddFloat(4, timeStamp, 0.0f); }
  public static Offset<rlbot.flat.QuickChat> EndQuickChat(FlatBufferBuilder builder) {
    int o = builder.EndTable();
    return new Offset<rlbot.flat.QuickChat>(o);
  }
  public static void FinishQuickChatBuffer(FlatBufferBuilder builder, Offset<rlbot.flat.QuickChat> offset) { builder.Finish(offset.Value); }
  public static void FinishSizePrefixedQuickChatBuffer(FlatBufferBuilder builder, Offset<rlbot.flat.QuickChat> offset) { builder.FinishSizePrefixed(offset.Value); }
}


static public class QuickChatVerify
{
  static public bool Verify(Google.FlatBuffers.Verifier verifier, uint tablePos)
  {
    return verifier.VerifyTableStart(tablePos)
      && verifier.VerifyField(tablePos, 4 /*QuickChatSelection*/, 1 /*rlbot.flat.QuickChatSelection*/, 1, false)
      && verifier.VerifyField(tablePos, 6 /*PlayerIndex*/, 4 /*int*/, 4, false)
      && verifier.VerifyField(tablePos, 8 /*TeamOnly*/, 1 /*bool*/, 1, false)
      && verifier.VerifyField(tablePos, 10 /*MessageIndex*/, 4 /*int*/, 4, false)
      && verifier.VerifyField(tablePos, 12 /*TimeStamp*/, 4 /*float*/, 4, false)
      && verifier.VerifyTableEnd(tablePos);
  }
}
/// A minimal version of player data, useful when bandwidth needs to be conserved.
public struct TinyPlayer : IFlatbufferObject
{
  private Table __p;
  public ByteBuffer ByteBuffer { get { return __p.bb; } }
  public static void ValidateVersion() { FlatBufferConstants.FLATBUFFERS_23_5_26(); }
  public static TinyPlayer GetRootAsTinyPlayer(ByteBuffer _bb) { return GetRootAsTinyPlayer(_bb, new TinyPlayer()); }
  public static TinyPlayer GetRootAsTinyPlayer(ByteBuffer _bb, TinyPlayer obj) { return (obj.__assign(_bb.GetInt(_bb.Position) + _bb.Position, _bb)); }
  public void __init(int _i, ByteBuffer _bb) { __p = new Table(_i, _bb); }
  public TinyPlayer __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }

  public rlbot.flat.Vector3? Location { get { int o = __p.__offset(4); return o != 0 ? (rlbot.flat.Vector3?)(new rlbot.flat.Vector3()).__assign(o + __p.bb_pos, __p.bb) : null; } }
  public rlbot.flat.Rotator? Rotation { get { int o = __p.__offset(6); return o != 0 ? (rlbot.flat.Rotator?)(new rlbot.flat.Rotator()).__assign(o + __p.bb_pos, __p.bb) : null; } }
  public rlbot.flat.Vector3? Velocity { get { int o = __p.__offset(8); return o != 0 ? (rlbot.flat.Vector3?)(new rlbot.flat.Vector3()).__assign(o + __p.bb_pos, __p.bb) : null; } }
  public bool HasWheelContact { get { int o = __p.__offset(10); return o != 0 ? 0!=__p.bb.Get(o + __p.bb_pos) : (bool)false; } }
  public bool IsSupersonic { get { int o = __p.__offset(12); return o != 0 ? 0!=__p.bb.Get(o + __p.bb_pos) : (bool)false; } }
  public int Team { get { int o = __p.__offset(14); return o != 0 ? __p.bb.GetInt(o + __p.bb_pos) : (int)0; } }
  public int Boost { get { int o = __p.__offset(16); return o != 0 ? __p.bb.GetInt(o + __p.bb_pos) : (int)0; } }

  public static void StartTinyPlayer(FlatBufferBuilder builder) { builder.StartTable(7); }
  public static void AddLocation(FlatBufferBuilder builder, Offset<rlbot.flat.Vector3> locationOffset) { builder.AddStruct(0, locationOffset.Value, 0); }
  public static void AddRotation(FlatBufferBuilder builder, Offset<rlbot.flat.Rotator> rotationOffset) { builder.AddStruct(1, rotationOffset.Value, 0); }
  public static void AddVelocity(FlatBufferBuilder builder, Offset<rlbot.flat.Vector3> velocityOffset) { builder.AddStruct(2, velocityOffset.Value, 0); }
  public static void AddHasWheelContact(FlatBufferBuilder builder, bool hasWheelContact) { builder.AddBool(3, hasWheelContact, false); }
  public static void AddIsSupersonic(FlatBufferBuilder builder, bool isSupersonic) { builder.AddBool(4, isSupersonic, false); }
  public static void AddTeam(FlatBufferBuilder builder, int team) { builder.AddInt(5, team, 0); }
  public static void AddBoost(FlatBufferBuilder builder, int boost) { builder.AddInt(6, boost, 0); }
  public static Offset<rlbot.flat.TinyPlayer> EndTinyPlayer(FlatBufferBuilder builder) {
    int o = builder.EndTable();
    return new Offset<rlbot.flat.TinyPlayer>(o);
  }
}


static public class TinyPlayerVerify
{
  static public bool Verify(Google.FlatBuffers.Verifier verifier, uint tablePos)
  {
    return verifier.VerifyTableStart(tablePos)
      && verifier.VerifyField(tablePos, 4 /*Location*/, 12 /*rlbot.flat.Vector3*/, 4, false)
      && verifier.VerifyField(tablePos, 6 /*Rotation*/, 12 /*rlbot.flat.Rotator*/, 4, false)
      && verifier.VerifyField(tablePos, 8 /*Velocity*/, 12 /*rlbot.flat.Vector3*/, 4, false)
      && verifier.VerifyField(tablePos, 10 /*HasWheelContact*/, 1 /*bool*/, 1, false)
      && verifier.VerifyField(tablePos, 12 /*IsSupersonic*/, 1 /*bool*/, 1, false)
      && verifier.VerifyField(tablePos, 14 /*Team*/, 4 /*int*/, 4, false)
      && verifier.VerifyField(tablePos, 16 /*Boost*/, 4 /*int*/, 4, false)
      && verifier.VerifyTableEnd(tablePos);
  }
}
/// A minimal version of the ball, useful when bandwidth needs to be conserved.
public struct TinyBall : IFlatbufferObject
{
  private Table __p;
  public ByteBuffer ByteBuffer { get { return __p.bb; } }
  public static void ValidateVersion() { FlatBufferConstants.FLATBUFFERS_23_5_26(); }
  public static TinyBall GetRootAsTinyBall(ByteBuffer _bb) { return GetRootAsTinyBall(_bb, new TinyBall()); }
  public static TinyBall GetRootAsTinyBall(ByteBuffer _bb, TinyBall obj) { return (obj.__assign(_bb.GetInt(_bb.Position) + _bb.Position, _bb)); }
  public void __init(int _i, ByteBuffer _bb) { __p = new Table(_i, _bb); }
  public TinyBall __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }

  public rlbot.flat.Vector3? Location { get { int o = __p.__offset(4); return o != 0 ? (rlbot.flat.Vector3?)(new rlbot.flat.Vector3()).__assign(o + __p.bb_pos, __p.bb) : null; } }
  public rlbot.flat.Vector3? Velocity { get { int o = __p.__offset(6); return o != 0 ? (rlbot.flat.Vector3?)(new rlbot.flat.Vector3()).__assign(o + __p.bb_pos, __p.bb) : null; } }

  public static void StartTinyBall(FlatBufferBuilder builder) { builder.StartTable(2); }
  public static void AddLocation(FlatBufferBuilder builder, Offset<rlbot.flat.Vector3> locationOffset) { builder.AddStruct(0, locationOffset.Value, 0); }
  public static void AddVelocity(FlatBufferBuilder builder, Offset<rlbot.flat.Vector3> velocityOffset) { builder.AddStruct(1, velocityOffset.Value, 0); }
  public static Offset<rlbot.flat.TinyBall> EndTinyBall(FlatBufferBuilder builder) {
    int o = builder.EndTable();
    return new Offset<rlbot.flat.TinyBall>(o);
  }
}


static public class TinyBallVerify
{
  static public bool Verify(Google.FlatBuffers.Verifier verifier, uint tablePos)
  {
    return verifier.VerifyTableStart(tablePos)
      && verifier.VerifyField(tablePos, 4 /*Location*/, 12 /*rlbot.flat.Vector3*/, 4, false)
      && verifier.VerifyField(tablePos, 6 /*Velocity*/, 12 /*rlbot.flat.Vector3*/, 4, false)
      && verifier.VerifyTableEnd(tablePos);
  }
}
/// A minimal version of the game tick packet, useful when bandwidth needs to be conserved.
public struct TinyPacket : IFlatbufferObject
{
  private Table __p;
  public ByteBuffer ByteBuffer { get { return __p.bb; } }
  public static void ValidateVersion() { FlatBufferConstants.FLATBUFFERS_23_5_26(); }
  public static TinyPacket GetRootAsTinyPacket(ByteBuffer _bb) { return GetRootAsTinyPacket(_bb, new TinyPacket()); }
  public static TinyPacket GetRootAsTinyPacket(ByteBuffer _bb, TinyPacket obj) { return (obj.__assign(_bb.GetInt(_bb.Position) + _bb.Position, _bb)); }
  public void __init(int _i, ByteBuffer _bb) { __p = new Table(_i, _bb); }
  public TinyPacket __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }

  public rlbot.flat.TinyPlayer? Players(int j) { int o = __p.__offset(4); return o != 0 ? (rlbot.flat.TinyPlayer?)(new rlbot.flat.TinyPlayer()).__assign(__p.__indirect(__p.__vector(o) + j * 4), __p.bb) : null; }
  public int PlayersLength { get { int o = __p.__offset(4); return o != 0 ? __p.__vector_len(o) : 0; } }
  public rlbot.flat.TinyBall? Ball { get { int o = __p.__offset(6); return o != 0 ? (rlbot.flat.TinyBall?)(new rlbot.flat.TinyBall()).__assign(__p.__indirect(o + __p.bb_pos), __p.bb) : null; } }

  public static Offset<rlbot.flat.TinyPacket> CreateTinyPacket(FlatBufferBuilder builder,
      VectorOffset playersOffset = default(VectorOffset),
      Offset<rlbot.flat.TinyBall> ballOffset = default(Offset<rlbot.flat.TinyBall>)) {
    builder.StartTable(2);
    TinyPacket.AddBall(builder, ballOffset);
    TinyPacket.AddPlayers(builder, playersOffset);
    return TinyPacket.EndTinyPacket(builder);
  }

  public static void StartTinyPacket(FlatBufferBuilder builder) { builder.StartTable(2); }
  public static void AddPlayers(FlatBufferBuilder builder, VectorOffset playersOffset) { builder.AddOffset(0, playersOffset.Value, 0); }
  public static VectorOffset CreatePlayersVector(FlatBufferBuilder builder, Offset<rlbot.flat.TinyPlayer>[] data) { builder.StartVector(4, data.Length, 4); for (int i = data.Length - 1; i >= 0; i--) builder.AddOffset(data[i].Value); return builder.EndVector(); }
  public static VectorOffset CreatePlayersVectorBlock(FlatBufferBuilder builder, Offset<rlbot.flat.TinyPlayer>[] data) { builder.StartVector(4, data.Length, 4); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreatePlayersVectorBlock(FlatBufferBuilder builder, ArraySegment<Offset<rlbot.flat.TinyPlayer>> data) { builder.StartVector(4, data.Count, 4); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreatePlayersVectorBlock(FlatBufferBuilder builder, IntPtr dataPtr, int sizeInBytes) { builder.StartVector(1, sizeInBytes, 1); builder.Add<Offset<rlbot.flat.TinyPlayer>>(dataPtr, sizeInBytes); return builder.EndVector(); }
  public static void StartPlayersVector(FlatBufferBuilder builder, int numElems) { builder.StartVector(4, numElems, 4); }
  public static void AddBall(FlatBufferBuilder builder, Offset<rlbot.flat.TinyBall> ballOffset) { builder.AddOffset(1, ballOffset.Value, 0); }
  public static Offset<rlbot.flat.TinyPacket> EndTinyPacket(FlatBufferBuilder builder) {
    int o = builder.EndTable();
    return new Offset<rlbot.flat.TinyPacket>(o);
  }
}


static public class TinyPacketVerify
{
  static public bool Verify(Google.FlatBuffers.Verifier verifier, uint tablePos)
  {
    return verifier.VerifyTableStart(tablePos)
      && verifier.VerifyVectorOfTables(tablePos, 4 /*Players*/, rlbot.flat.TinyPlayerVerify.Verify, false)
      && verifier.VerifyTable(tablePos, 6 /*Ball*/, rlbot.flat.TinyBallVerify.Verify, false)
      && verifier.VerifyTableEnd(tablePos);
  }
}
public struct PredictionSlice : IFlatbufferObject
{
  private Table __p;
  public ByteBuffer ByteBuffer { get { return __p.bb; } }
  public static void ValidateVersion() { FlatBufferConstants.FLATBUFFERS_23_5_26(); }
  public static PredictionSlice GetRootAsPredictionSlice(ByteBuffer _bb) { return GetRootAsPredictionSlice(_bb, new PredictionSlice()); }
  public static PredictionSlice GetRootAsPredictionSlice(ByteBuffer _bb, PredictionSlice obj) { return (obj.__assign(_bb.GetInt(_bb.Position) + _bb.Position, _bb)); }
  public void __init(int _i, ByteBuffer _bb) { __p = new Table(_i, _bb); }
  public PredictionSlice __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }

  /// The moment in game time that this prediction corresponds to.
  /// This corresponds to 'secondsElapsed' in the GameInfo table.
  public float GameSeconds { get { int o = __p.__offset(4); return o != 0 ? __p.bb.GetFloat(o + __p.bb_pos) : (float)0.0f; } }
  /// The predicted location and motion of the object.
  public rlbot.flat.Physics? Physics { get { int o = __p.__offset(6); return o != 0 ? (rlbot.flat.Physics?)(new rlbot.flat.Physics()).__assign(__p.__indirect(o + __p.bb_pos), __p.bb) : null; } }

  public static Offset<rlbot.flat.PredictionSlice> CreatePredictionSlice(FlatBufferBuilder builder,
      float gameSeconds = 0.0f,
      Offset<rlbot.flat.Physics> physicsOffset = default(Offset<rlbot.flat.Physics>)) {
    builder.StartTable(2);
    PredictionSlice.AddPhysics(builder, physicsOffset);
    PredictionSlice.AddGameSeconds(builder, gameSeconds);
    return PredictionSlice.EndPredictionSlice(builder);
  }

  public static void StartPredictionSlice(FlatBufferBuilder builder) { builder.StartTable(2); }
  public static void AddGameSeconds(FlatBufferBuilder builder, float gameSeconds) { builder.AddFloat(0, gameSeconds, 0.0f); }
  public static void AddPhysics(FlatBufferBuilder builder, Offset<rlbot.flat.Physics> physicsOffset) { builder.AddOffset(1, physicsOffset.Value, 0); }
  public static Offset<rlbot.flat.PredictionSlice> EndPredictionSlice(FlatBufferBuilder builder) {
    int o = builder.EndTable();
    return new Offset<rlbot.flat.PredictionSlice>(o);
  }
}


static public class PredictionSliceVerify
{
  static public bool Verify(Google.FlatBuffers.Verifier verifier, uint tablePos)
  {
    return verifier.VerifyTableStart(tablePos)
      && verifier.VerifyField(tablePos, 4 /*GameSeconds*/, 4 /*float*/, 4, false)
      && verifier.VerifyTable(tablePos, 6 /*Physics*/, rlbot.flat.PhysicsVerify.Verify, false)
      && verifier.VerifyTableEnd(tablePos);
  }
}
public struct BallPrediction : IFlatbufferObject
{
  private Table __p;
  public ByteBuffer ByteBuffer { get { return __p.bb; } }
  public static void ValidateVersion() { FlatBufferConstants.FLATBUFFERS_23_5_26(); }
  public static BallPrediction GetRootAsBallPrediction(ByteBuffer _bb) { return GetRootAsBallPrediction(_bb, new BallPrediction()); }
  public static BallPrediction GetRootAsBallPrediction(ByteBuffer _bb, BallPrediction obj) { return (obj.__assign(_bb.GetInt(_bb.Position) + _bb.Position, _bb)); }
  public void __init(int _i, ByteBuffer _bb) { __p = new Table(_i, _bb); }
  public BallPrediction __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }

  /// A list of places the ball will be at specific times in the future.
  /// It is guaranteed to sorted so that time increases with each slice.
  /// It is NOT guaranteed to have a consistent amount of time between slices.
  public rlbot.flat.PredictionSlice? Slices(int j) { int o = __p.__offset(4); return o != 0 ? (rlbot.flat.PredictionSlice?)(new rlbot.flat.PredictionSlice()).__assign(__p.__indirect(__p.__vector(o) + j * 4), __p.bb) : null; }
  public int SlicesLength { get { int o = __p.__offset(4); return o != 0 ? __p.__vector_len(o) : 0; } }

  public static Offset<rlbot.flat.BallPrediction> CreateBallPrediction(FlatBufferBuilder builder,
      VectorOffset slicesOffset = default(VectorOffset)) {
    builder.StartTable(1);
    BallPrediction.AddSlices(builder, slicesOffset);
    return BallPrediction.EndBallPrediction(builder);
  }

  public static void StartBallPrediction(FlatBufferBuilder builder) { builder.StartTable(1); }
  public static void AddSlices(FlatBufferBuilder builder, VectorOffset slicesOffset) { builder.AddOffset(0, slicesOffset.Value, 0); }
  public static VectorOffset CreateSlicesVector(FlatBufferBuilder builder, Offset<rlbot.flat.PredictionSlice>[] data) { builder.StartVector(4, data.Length, 4); for (int i = data.Length - 1; i >= 0; i--) builder.AddOffset(data[i].Value); return builder.EndVector(); }
  public static VectorOffset CreateSlicesVectorBlock(FlatBufferBuilder builder, Offset<rlbot.flat.PredictionSlice>[] data) { builder.StartVector(4, data.Length, 4); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreateSlicesVectorBlock(FlatBufferBuilder builder, ArraySegment<Offset<rlbot.flat.PredictionSlice>> data) { builder.StartVector(4, data.Count, 4); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreateSlicesVectorBlock(FlatBufferBuilder builder, IntPtr dataPtr, int sizeInBytes) { builder.StartVector(1, sizeInBytes, 1); builder.Add<Offset<rlbot.flat.PredictionSlice>>(dataPtr, sizeInBytes); return builder.EndVector(); }
  public static void StartSlicesVector(FlatBufferBuilder builder, int numElems) { builder.StartVector(4, numElems, 4); }
  public static Offset<rlbot.flat.BallPrediction> EndBallPrediction(FlatBufferBuilder builder) {
    int o = builder.EndTable();
    return new Offset<rlbot.flat.BallPrediction>(o);
  }
}


static public class BallPredictionVerify
{
  static public bool Verify(Google.FlatBuffers.Verifier verifier, uint tablePos)
  {
    return verifier.VerifyTableStart(tablePos)
      && verifier.VerifyVectorOfTables(tablePos, 4 /*Slices*/, rlbot.flat.PredictionSliceVerify.Verify, false)
      && verifier.VerifyTableEnd(tablePos);
  }
}
/// A bot controlled by the RLBot framework
public struct RLBotPlayer : IFlatbufferObject
{
  private Table __p;
  public ByteBuffer ByteBuffer { get { return __p.bb; } }
  public static void ValidateVersion() { FlatBufferConstants.FLATBUFFERS_23_5_26(); }
  public static RLBotPlayer GetRootAsRLBotPlayer(ByteBuffer _bb) { return GetRootAsRLBotPlayer(_bb, new RLBotPlayer()); }
  public static RLBotPlayer GetRootAsRLBotPlayer(ByteBuffer _bb, RLBotPlayer obj) { return (obj.__assign(_bb.GetInt(_bb.Position) + _bb.Position, _bb)); }
  public void __init(int _i, ByteBuffer _bb) { __p = new Table(_i, _bb); }
  public RLBotPlayer __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }


  public static void StartRLBotPlayer(FlatBufferBuilder builder) { builder.StartTable(0); }
  public static Offset<rlbot.flat.RLBotPlayer> EndRLBotPlayer(FlatBufferBuilder builder) {
    int o = builder.EndTable();
    return new Offset<rlbot.flat.RLBotPlayer>(o);
  }
}


static public class RLBotPlayerVerify
{
  static public bool Verify(Google.FlatBuffers.Verifier verifier, uint tablePos)
  {
    return verifier.VerifyTableStart(tablePos)
      && verifier.VerifyTableEnd(tablePos);
  }
}
/// A normal human player
public struct HumanPlayer : IFlatbufferObject
{
  private Table __p;
  public ByteBuffer ByteBuffer { get { return __p.bb; } }
  public static void ValidateVersion() { FlatBufferConstants.FLATBUFFERS_23_5_26(); }
  public static HumanPlayer GetRootAsHumanPlayer(ByteBuffer _bb) { return GetRootAsHumanPlayer(_bb, new HumanPlayer()); }
  public static HumanPlayer GetRootAsHumanPlayer(ByteBuffer _bb, HumanPlayer obj) { return (obj.__assign(_bb.GetInt(_bb.Position) + _bb.Position, _bb)); }
  public void __init(int _i, ByteBuffer _bb) { __p = new Table(_i, _bb); }
  public HumanPlayer __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }


  public static void StartHumanPlayer(FlatBufferBuilder builder) { builder.StartTable(0); }
  public static Offset<rlbot.flat.HumanPlayer> EndHumanPlayer(FlatBufferBuilder builder) {
    int o = builder.EndTable();
    return new Offset<rlbot.flat.HumanPlayer>(o);
  }
}


static public class HumanPlayerVerify
{
  static public bool Verify(Google.FlatBuffers.Verifier verifier, uint tablePos)
  {
    return verifier.VerifyTableStart(tablePos)
      && verifier.VerifyTableEnd(tablePos);
  }
}
/// A psyonix bot, e.g. All Star bot
public struct PsyonixBotPlayer : IFlatbufferObject
{
  private Table __p;
  public ByteBuffer ByteBuffer { get { return __p.bb; } }
  public static void ValidateVersion() { FlatBufferConstants.FLATBUFFERS_23_5_26(); }
  public static PsyonixBotPlayer GetRootAsPsyonixBotPlayer(ByteBuffer _bb) { return GetRootAsPsyonixBotPlayer(_bb, new PsyonixBotPlayer()); }
  public static PsyonixBotPlayer GetRootAsPsyonixBotPlayer(ByteBuffer _bb, PsyonixBotPlayer obj) { return (obj.__assign(_bb.GetInt(_bb.Position) + _bb.Position, _bb)); }
  public void __init(int _i, ByteBuffer _bb) { __p = new Table(_i, _bb); }
  public PsyonixBotPlayer __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }

  public float BotSkill { get { int o = __p.__offset(4); return o != 0 ? __p.bb.GetFloat(o + __p.bb_pos) : (float)0.0f; } }

  public static Offset<rlbot.flat.PsyonixBotPlayer> CreatePsyonixBotPlayer(FlatBufferBuilder builder,
      float botSkill = 0.0f) {
    builder.StartTable(1);
    PsyonixBotPlayer.AddBotSkill(builder, botSkill);
    return PsyonixBotPlayer.EndPsyonixBotPlayer(builder);
  }

  public static void StartPsyonixBotPlayer(FlatBufferBuilder builder) { builder.StartTable(1); }
  public static void AddBotSkill(FlatBufferBuilder builder, float botSkill) { builder.AddFloat(0, botSkill, 0.0f); }
  public static Offset<rlbot.flat.PsyonixBotPlayer> EndPsyonixBotPlayer(FlatBufferBuilder builder) {
    int o = builder.EndTable();
    return new Offset<rlbot.flat.PsyonixBotPlayer>(o);
  }
}


static public class PsyonixBotPlayerVerify
{
  static public bool Verify(Google.FlatBuffers.Verifier verifier, uint tablePos)
  {
    return verifier.VerifyTableStart(tablePos)
      && verifier.VerifyField(tablePos, 4 /*BotSkill*/, 4 /*float*/, 4, false)
      && verifier.VerifyTableEnd(tablePos);
  }
}
/// A player that Rocket League treats as human, e.g. has a dedicated camera and can do training mode,
/// but is actually controlled by a bot.
public struct PartyMemberBotPlayer : IFlatbufferObject
{
  private Table __p;
  public ByteBuffer ByteBuffer { get { return __p.bb; } }
  public static void ValidateVersion() { FlatBufferConstants.FLATBUFFERS_23_5_26(); }
  public static PartyMemberBotPlayer GetRootAsPartyMemberBotPlayer(ByteBuffer _bb) { return GetRootAsPartyMemberBotPlayer(_bb, new PartyMemberBotPlayer()); }
  public static PartyMemberBotPlayer GetRootAsPartyMemberBotPlayer(ByteBuffer _bb, PartyMemberBotPlayer obj) { return (obj.__assign(_bb.GetInt(_bb.Position) + _bb.Position, _bb)); }
  public void __init(int _i, ByteBuffer _bb) { __p = new Table(_i, _bb); }
  public PartyMemberBotPlayer __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }


  public static void StartPartyMemberBotPlayer(FlatBufferBuilder builder) { builder.StartTable(0); }
  public static Offset<rlbot.flat.PartyMemberBotPlayer> EndPartyMemberBotPlayer(FlatBufferBuilder builder) {
    int o = builder.EndTable();
    return new Offset<rlbot.flat.PartyMemberBotPlayer>(o);
  }
}


static public class PartyMemberBotPlayerVerify
{
  static public bool Verify(Google.FlatBuffers.Verifier verifier, uint tablePos)
  {
    return verifier.VerifyTableStart(tablePos)
      && verifier.VerifyTableEnd(tablePos);
  }
}
/// The car type, color, and other aspects of the player's appearance.
/// See https://github.com/RLBot/RLBot/wiki/Bot-Customization
public struct PlayerLoadout : IFlatbufferObject
{
  private Table __p;
  public ByteBuffer ByteBuffer { get { return __p.bb; } }
  public static void ValidateVersion() { FlatBufferConstants.FLATBUFFERS_23_5_26(); }
  public static PlayerLoadout GetRootAsPlayerLoadout(ByteBuffer _bb) { return GetRootAsPlayerLoadout(_bb, new PlayerLoadout()); }
  public static PlayerLoadout GetRootAsPlayerLoadout(ByteBuffer _bb, PlayerLoadout obj) { return (obj.__assign(_bb.GetInt(_bb.Position) + _bb.Position, _bb)); }
  public void __init(int _i, ByteBuffer _bb) { __p = new Table(_i, _bb); }
  public PlayerLoadout __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }

  public int TeamColorId { get { int o = __p.__offset(4); return o != 0 ? __p.bb.GetInt(o + __p.bb_pos) : (int)0; } }
  public int CustomColorId { get { int o = __p.__offset(6); return o != 0 ? __p.bb.GetInt(o + __p.bb_pos) : (int)0; } }
  public int CarId { get { int o = __p.__offset(8); return o != 0 ? __p.bb.GetInt(o + __p.bb_pos) : (int)0; } }
  public int DecalId { get { int o = __p.__offset(10); return o != 0 ? __p.bb.GetInt(o + __p.bb_pos) : (int)0; } }
  public int WheelsId { get { int o = __p.__offset(12); return o != 0 ? __p.bb.GetInt(o + __p.bb_pos) : (int)0; } }
  public int BoostId { get { int o = __p.__offset(14); return o != 0 ? __p.bb.GetInt(o + __p.bb_pos) : (int)0; } }
  public int AntennaId { get { int o = __p.__offset(16); return o != 0 ? __p.bb.GetInt(o + __p.bb_pos) : (int)0; } }
  public int HatId { get { int o = __p.__offset(18); return o != 0 ? __p.bb.GetInt(o + __p.bb_pos) : (int)0; } }
  public int PaintFinishId { get { int o = __p.__offset(20); return o != 0 ? __p.bb.GetInt(o + __p.bb_pos) : (int)0; } }
  public int CustomFinishId { get { int o = __p.__offset(22); return o != 0 ? __p.bb.GetInt(o + __p.bb_pos) : (int)0; } }
  public int EngineAudioId { get { int o = __p.__offset(24); return o != 0 ? __p.bb.GetInt(o + __p.bb_pos) : (int)0; } }
  public int TrailsId { get { int o = __p.__offset(26); return o != 0 ? __p.bb.GetInt(o + __p.bb_pos) : (int)0; } }
  public int GoalExplosionId { get { int o = __p.__offset(28); return o != 0 ? __p.bb.GetInt(o + __p.bb_pos) : (int)0; } }
  public rlbot.flat.LoadoutPaint? LoadoutPaint { get { int o = __p.__offset(30); return o != 0 ? (rlbot.flat.LoadoutPaint?)(new rlbot.flat.LoadoutPaint()).__assign(__p.__indirect(o + __p.bb_pos), __p.bb) : null; } }
  /// Sets the primary color of the car to the swatch that most closely matches the provided
  /// RGB color value. If set, this overrides teamColorId.
  public rlbot.flat.Color? PrimaryColorLookup { get { int o = __p.__offset(32); return o != 0 ? (rlbot.flat.Color?)(new rlbot.flat.Color()).__assign(__p.__indirect(o + __p.bb_pos), __p.bb) : null; } }
  /// Sets the secondary color of the car to the swatch that most closely matches the provided
  /// RGB color value. If set, this overrides customColorId.
  public rlbot.flat.Color? SecondaryColorLookup { get { int o = __p.__offset(34); return o != 0 ? (rlbot.flat.Color?)(new rlbot.flat.Color()).__assign(__p.__indirect(o + __p.bb_pos), __p.bb) : null; } }

  public static Offset<rlbot.flat.PlayerLoadout> CreatePlayerLoadout(FlatBufferBuilder builder,
      int teamColorId = 0,
      int customColorId = 0,
      int carId = 0,
      int decalId = 0,
      int wheelsId = 0,
      int boostId = 0,
      int antennaId = 0,
      int hatId = 0,
      int paintFinishId = 0,
      int customFinishId = 0,
      int engineAudioId = 0,
      int trailsId = 0,
      int goalExplosionId = 0,
      Offset<rlbot.flat.LoadoutPaint> loadoutPaintOffset = default(Offset<rlbot.flat.LoadoutPaint>),
      Offset<rlbot.flat.Color> primaryColorLookupOffset = default(Offset<rlbot.flat.Color>),
      Offset<rlbot.flat.Color> secondaryColorLookupOffset = default(Offset<rlbot.flat.Color>)) {
    builder.StartTable(16);
    PlayerLoadout.AddSecondaryColorLookup(builder, secondaryColorLookupOffset);
    PlayerLoadout.AddPrimaryColorLookup(builder, primaryColorLookupOffset);
    PlayerLoadout.AddLoadoutPaint(builder, loadoutPaintOffset);
    PlayerLoadout.AddGoalExplosionId(builder, goalExplosionId);
    PlayerLoadout.AddTrailsId(builder, trailsId);
    PlayerLoadout.AddEngineAudioId(builder, engineAudioId);
    PlayerLoadout.AddCustomFinishId(builder, customFinishId);
    PlayerLoadout.AddPaintFinishId(builder, paintFinishId);
    PlayerLoadout.AddHatId(builder, hatId);
    PlayerLoadout.AddAntennaId(builder, antennaId);
    PlayerLoadout.AddBoostId(builder, boostId);
    PlayerLoadout.AddWheelsId(builder, wheelsId);
    PlayerLoadout.AddDecalId(builder, decalId);
    PlayerLoadout.AddCarId(builder, carId);
    PlayerLoadout.AddCustomColorId(builder, customColorId);
    PlayerLoadout.AddTeamColorId(builder, teamColorId);
    return PlayerLoadout.EndPlayerLoadout(builder);
  }

  public static void StartPlayerLoadout(FlatBufferBuilder builder) { builder.StartTable(16); }
  public static void AddTeamColorId(FlatBufferBuilder builder, int teamColorId) { builder.AddInt(0, teamColorId, 0); }
  public static void AddCustomColorId(FlatBufferBuilder builder, int customColorId) { builder.AddInt(1, customColorId, 0); }
  public static void AddCarId(FlatBufferBuilder builder, int carId) { builder.AddInt(2, carId, 0); }
  public static void AddDecalId(FlatBufferBuilder builder, int decalId) { builder.AddInt(3, decalId, 0); }
  public static void AddWheelsId(FlatBufferBuilder builder, int wheelsId) { builder.AddInt(4, wheelsId, 0); }
  public static void AddBoostId(FlatBufferBuilder builder, int boostId) { builder.AddInt(5, boostId, 0); }
  public static void AddAntennaId(FlatBufferBuilder builder, int antennaId) { builder.AddInt(6, antennaId, 0); }
  public static void AddHatId(FlatBufferBuilder builder, int hatId) { builder.AddInt(7, hatId, 0); }
  public static void AddPaintFinishId(FlatBufferBuilder builder, int paintFinishId) { builder.AddInt(8, paintFinishId, 0); }
  public static void AddCustomFinishId(FlatBufferBuilder builder, int customFinishId) { builder.AddInt(9, customFinishId, 0); }
  public static void AddEngineAudioId(FlatBufferBuilder builder, int engineAudioId) { builder.AddInt(10, engineAudioId, 0); }
  public static void AddTrailsId(FlatBufferBuilder builder, int trailsId) { builder.AddInt(11, trailsId, 0); }
  public static void AddGoalExplosionId(FlatBufferBuilder builder, int goalExplosionId) { builder.AddInt(12, goalExplosionId, 0); }
  public static void AddLoadoutPaint(FlatBufferBuilder builder, Offset<rlbot.flat.LoadoutPaint> loadoutPaintOffset) { builder.AddOffset(13, loadoutPaintOffset.Value, 0); }
  public static void AddPrimaryColorLookup(FlatBufferBuilder builder, Offset<rlbot.flat.Color> primaryColorLookupOffset) { builder.AddOffset(14, primaryColorLookupOffset.Value, 0); }
  public static void AddSecondaryColorLookup(FlatBufferBuilder builder, Offset<rlbot.flat.Color> secondaryColorLookupOffset) { builder.AddOffset(15, secondaryColorLookupOffset.Value, 0); }
  public static Offset<rlbot.flat.PlayerLoadout> EndPlayerLoadout(FlatBufferBuilder builder) {
    int o = builder.EndTable();
    return new Offset<rlbot.flat.PlayerLoadout>(o);
  }
}


static public class PlayerLoadoutVerify
{
  static public bool Verify(Google.FlatBuffers.Verifier verifier, uint tablePos)
  {
    return verifier.VerifyTableStart(tablePos)
      && verifier.VerifyField(tablePos, 4 /*TeamColorId*/, 4 /*int*/, 4, false)
      && verifier.VerifyField(tablePos, 6 /*CustomColorId*/, 4 /*int*/, 4, false)
      && verifier.VerifyField(tablePos, 8 /*CarId*/, 4 /*int*/, 4, false)
      && verifier.VerifyField(tablePos, 10 /*DecalId*/, 4 /*int*/, 4, false)
      && verifier.VerifyField(tablePos, 12 /*WheelsId*/, 4 /*int*/, 4, false)
      && verifier.VerifyField(tablePos, 14 /*BoostId*/, 4 /*int*/, 4, false)
      && verifier.VerifyField(tablePos, 16 /*AntennaId*/, 4 /*int*/, 4, false)
      && verifier.VerifyField(tablePos, 18 /*HatId*/, 4 /*int*/, 4, false)
      && verifier.VerifyField(tablePos, 20 /*PaintFinishId*/, 4 /*int*/, 4, false)
      && verifier.VerifyField(tablePos, 22 /*CustomFinishId*/, 4 /*int*/, 4, false)
      && verifier.VerifyField(tablePos, 24 /*EngineAudioId*/, 4 /*int*/, 4, false)
      && verifier.VerifyField(tablePos, 26 /*TrailsId*/, 4 /*int*/, 4, false)
      && verifier.VerifyField(tablePos, 28 /*GoalExplosionId*/, 4 /*int*/, 4, false)
      && verifier.VerifyTable(tablePos, 30 /*LoadoutPaint*/, rlbot.flat.LoadoutPaintVerify.Verify, false)
      && verifier.VerifyTable(tablePos, 32 /*PrimaryColorLookup*/, rlbot.flat.ColorVerify.Verify, false)
      && verifier.VerifyTable(tablePos, 34 /*SecondaryColorLookup*/, rlbot.flat.ColorVerify.Verify, false)
      && verifier.VerifyTableEnd(tablePos);
  }
}
/// Specification for 'painted' items. See https://github.com/RLBot/RLBot/wiki/Bot-Customization
public struct LoadoutPaint : IFlatbufferObject
{
  private Table __p;
  public ByteBuffer ByteBuffer { get { return __p.bb; } }
  public static void ValidateVersion() { FlatBufferConstants.FLATBUFFERS_23_5_26(); }
  public static LoadoutPaint GetRootAsLoadoutPaint(ByteBuffer _bb) { return GetRootAsLoadoutPaint(_bb, new LoadoutPaint()); }
  public static LoadoutPaint GetRootAsLoadoutPaint(ByteBuffer _bb, LoadoutPaint obj) { return (obj.__assign(_bb.GetInt(_bb.Position) + _bb.Position, _bb)); }
  public void __init(int _i, ByteBuffer _bb) { __p = new Table(_i, _bb); }
  public LoadoutPaint __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }

  public int CarPaintId { get { int o = __p.__offset(4); return o != 0 ? __p.bb.GetInt(o + __p.bb_pos) : (int)0; } }
  public int DecalPaintId { get { int o = __p.__offset(6); return o != 0 ? __p.bb.GetInt(o + __p.bb_pos) : (int)0; } }
  public int WheelsPaintId { get { int o = __p.__offset(8); return o != 0 ? __p.bb.GetInt(o + __p.bb_pos) : (int)0; } }
  public int BoostPaintId { get { int o = __p.__offset(10); return o != 0 ? __p.bb.GetInt(o + __p.bb_pos) : (int)0; } }
  public int AntennaPaintId { get { int o = __p.__offset(12); return o != 0 ? __p.bb.GetInt(o + __p.bb_pos) : (int)0; } }
  public int HatPaintId { get { int o = __p.__offset(14); return o != 0 ? __p.bb.GetInt(o + __p.bb_pos) : (int)0; } }
  public int TrailsPaintId { get { int o = __p.__offset(16); return o != 0 ? __p.bb.GetInt(o + __p.bb_pos) : (int)0; } }
  public int GoalExplosionPaintId { get { int o = __p.__offset(18); return o != 0 ? __p.bb.GetInt(o + __p.bb_pos) : (int)0; } }

  public static Offset<rlbot.flat.LoadoutPaint> CreateLoadoutPaint(FlatBufferBuilder builder,
      int carPaintId = 0,
      int decalPaintId = 0,
      int wheelsPaintId = 0,
      int boostPaintId = 0,
      int antennaPaintId = 0,
      int hatPaintId = 0,
      int trailsPaintId = 0,
      int goalExplosionPaintId = 0) {
    builder.StartTable(8);
    LoadoutPaint.AddGoalExplosionPaintId(builder, goalExplosionPaintId);
    LoadoutPaint.AddTrailsPaintId(builder, trailsPaintId);
    LoadoutPaint.AddHatPaintId(builder, hatPaintId);
    LoadoutPaint.AddAntennaPaintId(builder, antennaPaintId);
    LoadoutPaint.AddBoostPaintId(builder, boostPaintId);
    LoadoutPaint.AddWheelsPaintId(builder, wheelsPaintId);
    LoadoutPaint.AddDecalPaintId(builder, decalPaintId);
    LoadoutPaint.AddCarPaintId(builder, carPaintId);
    return LoadoutPaint.EndLoadoutPaint(builder);
  }

  public static void StartLoadoutPaint(FlatBufferBuilder builder) { builder.StartTable(8); }
  public static void AddCarPaintId(FlatBufferBuilder builder, int carPaintId) { builder.AddInt(0, carPaintId, 0); }
  public static void AddDecalPaintId(FlatBufferBuilder builder, int decalPaintId) { builder.AddInt(1, decalPaintId, 0); }
  public static void AddWheelsPaintId(FlatBufferBuilder builder, int wheelsPaintId) { builder.AddInt(2, wheelsPaintId, 0); }
  public static void AddBoostPaintId(FlatBufferBuilder builder, int boostPaintId) { builder.AddInt(3, boostPaintId, 0); }
  public static void AddAntennaPaintId(FlatBufferBuilder builder, int antennaPaintId) { builder.AddInt(4, antennaPaintId, 0); }
  public static void AddHatPaintId(FlatBufferBuilder builder, int hatPaintId) { builder.AddInt(5, hatPaintId, 0); }
  public static void AddTrailsPaintId(FlatBufferBuilder builder, int trailsPaintId) { builder.AddInt(6, trailsPaintId, 0); }
  public static void AddGoalExplosionPaintId(FlatBufferBuilder builder, int goalExplosionPaintId) { builder.AddInt(7, goalExplosionPaintId, 0); }
  public static Offset<rlbot.flat.LoadoutPaint> EndLoadoutPaint(FlatBufferBuilder builder) {
    int o = builder.EndTable();
    return new Offset<rlbot.flat.LoadoutPaint>(o);
  }
}


static public class LoadoutPaintVerify
{
  static public bool Verify(Google.FlatBuffers.Verifier verifier, uint tablePos)
  {
    return verifier.VerifyTableStart(tablePos)
      && verifier.VerifyField(tablePos, 4 /*CarPaintId*/, 4 /*int*/, 4, false)
      && verifier.VerifyField(tablePos, 6 /*DecalPaintId*/, 4 /*int*/, 4, false)
      && verifier.VerifyField(tablePos, 8 /*WheelsPaintId*/, 4 /*int*/, 4, false)
      && verifier.VerifyField(tablePos, 10 /*BoostPaintId*/, 4 /*int*/, 4, false)
      && verifier.VerifyField(tablePos, 12 /*AntennaPaintId*/, 4 /*int*/, 4, false)
      && verifier.VerifyField(tablePos, 14 /*HatPaintId*/, 4 /*int*/, 4, false)
      && verifier.VerifyField(tablePos, 16 /*TrailsPaintId*/, 4 /*int*/, 4, false)
      && verifier.VerifyField(tablePos, 18 /*GoalExplosionPaintId*/, 4 /*int*/, 4, false)
      && verifier.VerifyTableEnd(tablePos);
  }
}
public struct PlayerConfiguration : IFlatbufferObject
{
  private Table __p;
  public ByteBuffer ByteBuffer { get { return __p.bb; } }
  public static void ValidateVersion() { FlatBufferConstants.FLATBUFFERS_23_5_26(); }
  public static PlayerConfiguration GetRootAsPlayerConfiguration(ByteBuffer _bb) { return GetRootAsPlayerConfiguration(_bb, new PlayerConfiguration()); }
  public static PlayerConfiguration GetRootAsPlayerConfiguration(ByteBuffer _bb, PlayerConfiguration obj) { return (obj.__assign(_bb.GetInt(_bb.Position) + _bb.Position, _bb)); }
  public void __init(int _i, ByteBuffer _bb) { __p = new Table(_i, _bb); }
  public PlayerConfiguration __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }

  public rlbot.flat.PlayerClass VarietyType { get { int o = __p.__offset(4); return o != 0 ? (rlbot.flat.PlayerClass)__p.bb.Get(o + __p.bb_pos) : rlbot.flat.PlayerClass.NONE; } }
  public TTable? Variety<TTable>() where TTable : struct, IFlatbufferObject { int o = __p.__offset(6); return o != 0 ? (TTable?)__p.__union<TTable>(o + __p.bb_pos) : null; }
  public rlbot.flat.RLBotPlayer VarietyAsRLBotPlayer() { return Variety<rlbot.flat.RLBotPlayer>().Value; }
  public rlbot.flat.HumanPlayer VarietyAsHumanPlayer() { return Variety<rlbot.flat.HumanPlayer>().Value; }
  public rlbot.flat.PsyonixBotPlayer VarietyAsPsyonixBotPlayer() { return Variety<rlbot.flat.PsyonixBotPlayer>().Value; }
  public rlbot.flat.PartyMemberBotPlayer VarietyAsPartyMemberBotPlayer() { return Variety<rlbot.flat.PartyMemberBotPlayer>().Value; }
  public string Name { get { int o = __p.__offset(8); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetNameBytes() { return __p.__vector_as_span<byte>(8, 1); }
#else
  public ArraySegment<byte>? GetNameBytes() { return __p.__vector_as_arraysegment(8); }
#endif
  public byte[] GetNameArray() { return __p.__vector_as_array<byte>(8); }
  public int Team { get { int o = __p.__offset(10); return o != 0 ? __p.bb.GetInt(o + __p.bb_pos) : (int)0; } }
  public rlbot.flat.PlayerLoadout? Loadout { get { int o = __p.__offset(12); return o != 0 ? (rlbot.flat.PlayerLoadout?)(new rlbot.flat.PlayerLoadout()).__assign(__p.__indirect(o + __p.bb_pos), __p.bb) : null; } }
  /// In the case where the requested player index is not available, spawnId will help
  /// the framework figure out what index was actually assigned to this player instead.
  public int SpawnId { get { int o = __p.__offset(14); return o != 0 ? __p.bb.GetInt(o + __p.bb_pos) : (int)0; } }

  public static Offset<rlbot.flat.PlayerConfiguration> CreatePlayerConfiguration(FlatBufferBuilder builder,
      rlbot.flat.PlayerClass variety_type = rlbot.flat.PlayerClass.NONE,
      int varietyOffset = 0,
      StringOffset nameOffset = default(StringOffset),
      int team = 0,
      Offset<rlbot.flat.PlayerLoadout> loadoutOffset = default(Offset<rlbot.flat.PlayerLoadout>),
      int spawnId = 0) {
    builder.StartTable(6);
    PlayerConfiguration.AddSpawnId(builder, spawnId);
    PlayerConfiguration.AddLoadout(builder, loadoutOffset);
    PlayerConfiguration.AddTeam(builder, team);
    PlayerConfiguration.AddName(builder, nameOffset);
    PlayerConfiguration.AddVariety(builder, varietyOffset);
    PlayerConfiguration.AddVarietyType(builder, variety_type);
    return PlayerConfiguration.EndPlayerConfiguration(builder);
  }

  public static void StartPlayerConfiguration(FlatBufferBuilder builder) { builder.StartTable(6); }
  public static void AddVarietyType(FlatBufferBuilder builder, rlbot.flat.PlayerClass varietyType) { builder.AddByte(0, (byte)varietyType, 0); }
  public static void AddVariety(FlatBufferBuilder builder, int varietyOffset) { builder.AddOffset(1, varietyOffset, 0); }
  public static void AddName(FlatBufferBuilder builder, StringOffset nameOffset) { builder.AddOffset(2, nameOffset.Value, 0); }
  public static void AddTeam(FlatBufferBuilder builder, int team) { builder.AddInt(3, team, 0); }
  public static void AddLoadout(FlatBufferBuilder builder, Offset<rlbot.flat.PlayerLoadout> loadoutOffset) { builder.AddOffset(4, loadoutOffset.Value, 0); }
  public static void AddSpawnId(FlatBufferBuilder builder, int spawnId) { builder.AddInt(5, spawnId, 0); }
  public static Offset<rlbot.flat.PlayerConfiguration> EndPlayerConfiguration(FlatBufferBuilder builder) {
    int o = builder.EndTable();
    return new Offset<rlbot.flat.PlayerConfiguration>(o);
  }
}


static public class PlayerConfigurationVerify
{
  static public bool Verify(Google.FlatBuffers.Verifier verifier, uint tablePos)
  {
    return verifier.VerifyTableStart(tablePos)
      && verifier.VerifyField(tablePos, 4 /*VarietyType*/, 1 /*rlbot.flat.PlayerClass*/, 1, false)
      && verifier.VerifyUnion(tablePos, 4, 6 /*Variety*/, rlbot.flat.PlayerClassVerify.Verify, false)
      && verifier.VerifyString(tablePos, 8 /*Name*/, false)
      && verifier.VerifyField(tablePos, 10 /*Team*/, 4 /*int*/, 4, false)
      && verifier.VerifyTable(tablePos, 12 /*Loadout*/, rlbot.flat.PlayerLoadoutVerify.Verify, false)
      && verifier.VerifyField(tablePos, 14 /*SpawnId*/, 4 /*int*/, 4, false)
      && verifier.VerifyTableEnd(tablePos);
  }
}
public struct MutatorSettings : IFlatbufferObject
{
  private Table __p;
  public ByteBuffer ByteBuffer { get { return __p.bb; } }
  public static void ValidateVersion() { FlatBufferConstants.FLATBUFFERS_23_5_26(); }
  public static MutatorSettings GetRootAsMutatorSettings(ByteBuffer _bb) { return GetRootAsMutatorSettings(_bb, new MutatorSettings()); }
  public static MutatorSettings GetRootAsMutatorSettings(ByteBuffer _bb, MutatorSettings obj) { return (obj.__assign(_bb.GetInt(_bb.Position) + _bb.Position, _bb)); }
  public void __init(int _i, ByteBuffer _bb) { __p = new Table(_i, _bb); }
  public MutatorSettings __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }

  public rlbot.flat.MatchLength MatchLength { get { int o = __p.__offset(4); return o != 0 ? (rlbot.flat.MatchLength)__p.bb.GetSbyte(o + __p.bb_pos) : rlbot.flat.MatchLength.Five_Minutes; } }
  public rlbot.flat.MaxScore MaxScore { get { int o = __p.__offset(6); return o != 0 ? (rlbot.flat.MaxScore)__p.bb.GetSbyte(o + __p.bb_pos) : rlbot.flat.MaxScore.Unlimited; } }
  public rlbot.flat.OvertimeOption OvertimeOption { get { int o = __p.__offset(8); return o != 0 ? (rlbot.flat.OvertimeOption)__p.bb.GetSbyte(o + __p.bb_pos) : rlbot.flat.OvertimeOption.Unlimited; } }
  public rlbot.flat.SeriesLengthOption SeriesLengthOption { get { int o = __p.__offset(10); return o != 0 ? (rlbot.flat.SeriesLengthOption)__p.bb.GetSbyte(o + __p.bb_pos) : rlbot.flat.SeriesLengthOption.Unlimited; } }
  public rlbot.flat.GameSpeedOption GameSpeedOption { get { int o = __p.__offset(12); return o != 0 ? (rlbot.flat.GameSpeedOption)__p.bb.GetSbyte(o + __p.bb_pos) : rlbot.flat.GameSpeedOption.Default; } }
  public rlbot.flat.BallMaxSpeedOption BallMaxSpeedOption { get { int o = __p.__offset(14); return o != 0 ? (rlbot.flat.BallMaxSpeedOption)__p.bb.GetSbyte(o + __p.bb_pos) : rlbot.flat.BallMaxSpeedOption.Default; } }
  public rlbot.flat.BallTypeOption BallTypeOption { get { int o = __p.__offset(16); return o != 0 ? (rlbot.flat.BallTypeOption)__p.bb.GetSbyte(o + __p.bb_pos) : rlbot.flat.BallTypeOption.Default; } }
  public rlbot.flat.BallWeightOption BallWeightOption { get { int o = __p.__offset(18); return o != 0 ? (rlbot.flat.BallWeightOption)__p.bb.GetSbyte(o + __p.bb_pos) : rlbot.flat.BallWeightOption.Default; } }
  public rlbot.flat.BallSizeOption BallSizeOption { get { int o = __p.__offset(20); return o != 0 ? (rlbot.flat.BallSizeOption)__p.bb.GetSbyte(o + __p.bb_pos) : rlbot.flat.BallSizeOption.Default; } }
  public rlbot.flat.BallBouncinessOption BallBouncinessOption { get { int o = __p.__offset(22); return o != 0 ? (rlbot.flat.BallBouncinessOption)__p.bb.GetSbyte(o + __p.bb_pos) : rlbot.flat.BallBouncinessOption.Default; } }
  public rlbot.flat.BoostOption BoostOption { get { int o = __p.__offset(24); return o != 0 ? (rlbot.flat.BoostOption)__p.bb.GetSbyte(o + __p.bb_pos) : rlbot.flat.BoostOption.Normal_Boost; } }
  public rlbot.flat.RumbleOption RumbleOption { get { int o = __p.__offset(26); return o != 0 ? (rlbot.flat.RumbleOption)__p.bb.GetSbyte(o + __p.bb_pos) : rlbot.flat.RumbleOption.No_Rumble; } }
  public rlbot.flat.BoostStrengthOption BoostStrengthOption { get { int o = __p.__offset(28); return o != 0 ? (rlbot.flat.BoostStrengthOption)__p.bb.GetSbyte(o + __p.bb_pos) : rlbot.flat.BoostStrengthOption.One; } }
  public rlbot.flat.GravityOption GravityOption { get { int o = __p.__offset(30); return o != 0 ? (rlbot.flat.GravityOption)__p.bb.GetSbyte(o + __p.bb_pos) : rlbot.flat.GravityOption.Default; } }
  public rlbot.flat.DemolishOption DemolishOption { get { int o = __p.__offset(32); return o != 0 ? (rlbot.flat.DemolishOption)__p.bb.GetSbyte(o + __p.bb_pos) : rlbot.flat.DemolishOption.Default; } }
  public rlbot.flat.RespawnTimeOption RespawnTimeOption { get { int o = __p.__offset(34); return o != 0 ? (rlbot.flat.RespawnTimeOption)__p.bb.GetSbyte(o + __p.bb_pos) : rlbot.flat.RespawnTimeOption.Three_Seconds; } }

  public static Offset<rlbot.flat.MutatorSettings> CreateMutatorSettings(FlatBufferBuilder builder,
      rlbot.flat.MatchLength matchLength = rlbot.flat.MatchLength.Five_Minutes,
      rlbot.flat.MaxScore maxScore = rlbot.flat.MaxScore.Unlimited,
      rlbot.flat.OvertimeOption overtimeOption = rlbot.flat.OvertimeOption.Unlimited,
      rlbot.flat.SeriesLengthOption seriesLengthOption = rlbot.flat.SeriesLengthOption.Unlimited,
      rlbot.flat.GameSpeedOption gameSpeedOption = rlbot.flat.GameSpeedOption.Default,
      rlbot.flat.BallMaxSpeedOption ballMaxSpeedOption = rlbot.flat.BallMaxSpeedOption.Default,
      rlbot.flat.BallTypeOption ballTypeOption = rlbot.flat.BallTypeOption.Default,
      rlbot.flat.BallWeightOption ballWeightOption = rlbot.flat.BallWeightOption.Default,
      rlbot.flat.BallSizeOption ballSizeOption = rlbot.flat.BallSizeOption.Default,
      rlbot.flat.BallBouncinessOption ballBouncinessOption = rlbot.flat.BallBouncinessOption.Default,
      rlbot.flat.BoostOption boostOption = rlbot.flat.BoostOption.Normal_Boost,
      rlbot.flat.RumbleOption rumbleOption = rlbot.flat.RumbleOption.No_Rumble,
      rlbot.flat.BoostStrengthOption boostStrengthOption = rlbot.flat.BoostStrengthOption.One,
      rlbot.flat.GravityOption gravityOption = rlbot.flat.GravityOption.Default,
      rlbot.flat.DemolishOption demolishOption = rlbot.flat.DemolishOption.Default,
      rlbot.flat.RespawnTimeOption respawnTimeOption = rlbot.flat.RespawnTimeOption.Three_Seconds) {
    builder.StartTable(16);
    MutatorSettings.AddRespawnTimeOption(builder, respawnTimeOption);
    MutatorSettings.AddDemolishOption(builder, demolishOption);
    MutatorSettings.AddGravityOption(builder, gravityOption);
    MutatorSettings.AddBoostStrengthOption(builder, boostStrengthOption);
    MutatorSettings.AddRumbleOption(builder, rumbleOption);
    MutatorSettings.AddBoostOption(builder, boostOption);
    MutatorSettings.AddBallBouncinessOption(builder, ballBouncinessOption);
    MutatorSettings.AddBallSizeOption(builder, ballSizeOption);
    MutatorSettings.AddBallWeightOption(builder, ballWeightOption);
    MutatorSettings.AddBallTypeOption(builder, ballTypeOption);
    MutatorSettings.AddBallMaxSpeedOption(builder, ballMaxSpeedOption);
    MutatorSettings.AddGameSpeedOption(builder, gameSpeedOption);
    MutatorSettings.AddSeriesLengthOption(builder, seriesLengthOption);
    MutatorSettings.AddOvertimeOption(builder, overtimeOption);
    MutatorSettings.AddMaxScore(builder, maxScore);
    MutatorSettings.AddMatchLength(builder, matchLength);
    return MutatorSettings.EndMutatorSettings(builder);
  }

  public static void StartMutatorSettings(FlatBufferBuilder builder) { builder.StartTable(16); }
  public static void AddMatchLength(FlatBufferBuilder builder, rlbot.flat.MatchLength matchLength) { builder.AddSbyte(0, (sbyte)matchLength, 0); }
  public static void AddMaxScore(FlatBufferBuilder builder, rlbot.flat.MaxScore maxScore) { builder.AddSbyte(1, (sbyte)maxScore, 0); }
  public static void AddOvertimeOption(FlatBufferBuilder builder, rlbot.flat.OvertimeOption overtimeOption) { builder.AddSbyte(2, (sbyte)overtimeOption, 0); }
  public static void AddSeriesLengthOption(FlatBufferBuilder builder, rlbot.flat.SeriesLengthOption seriesLengthOption) { builder.AddSbyte(3, (sbyte)seriesLengthOption, 0); }
  public static void AddGameSpeedOption(FlatBufferBuilder builder, rlbot.flat.GameSpeedOption gameSpeedOption) { builder.AddSbyte(4, (sbyte)gameSpeedOption, 0); }
  public static void AddBallMaxSpeedOption(FlatBufferBuilder builder, rlbot.flat.BallMaxSpeedOption ballMaxSpeedOption) { builder.AddSbyte(5, (sbyte)ballMaxSpeedOption, 0); }
  public static void AddBallTypeOption(FlatBufferBuilder builder, rlbot.flat.BallTypeOption ballTypeOption) { builder.AddSbyte(6, (sbyte)ballTypeOption, 0); }
  public static void AddBallWeightOption(FlatBufferBuilder builder, rlbot.flat.BallWeightOption ballWeightOption) { builder.AddSbyte(7, (sbyte)ballWeightOption, 0); }
  public static void AddBallSizeOption(FlatBufferBuilder builder, rlbot.flat.BallSizeOption ballSizeOption) { builder.AddSbyte(8, (sbyte)ballSizeOption, 0); }
  public static void AddBallBouncinessOption(FlatBufferBuilder builder, rlbot.flat.BallBouncinessOption ballBouncinessOption) { builder.AddSbyte(9, (sbyte)ballBouncinessOption, 0); }
  public static void AddBoostOption(FlatBufferBuilder builder, rlbot.flat.BoostOption boostOption) { builder.AddSbyte(10, (sbyte)boostOption, 0); }
  public static void AddRumbleOption(FlatBufferBuilder builder, rlbot.flat.RumbleOption rumbleOption) { builder.AddSbyte(11, (sbyte)rumbleOption, 0); }
  public static void AddBoostStrengthOption(FlatBufferBuilder builder, rlbot.flat.BoostStrengthOption boostStrengthOption) { builder.AddSbyte(12, (sbyte)boostStrengthOption, 0); }
  public static void AddGravityOption(FlatBufferBuilder builder, rlbot.flat.GravityOption gravityOption) { builder.AddSbyte(13, (sbyte)gravityOption, 0); }
  public static void AddDemolishOption(FlatBufferBuilder builder, rlbot.flat.DemolishOption demolishOption) { builder.AddSbyte(14, (sbyte)demolishOption, 0); }
  public static void AddRespawnTimeOption(FlatBufferBuilder builder, rlbot.flat.RespawnTimeOption respawnTimeOption) { builder.AddSbyte(15, (sbyte)respawnTimeOption, 0); }
  public static Offset<rlbot.flat.MutatorSettings> EndMutatorSettings(FlatBufferBuilder builder) {
    int o = builder.EndTable();
    return new Offset<rlbot.flat.MutatorSettings>(o);
  }
}


static public class MutatorSettingsVerify
{
  static public bool Verify(Google.FlatBuffers.Verifier verifier, uint tablePos)
  {
    return verifier.VerifyTableStart(tablePos)
      && verifier.VerifyField(tablePos, 4 /*MatchLength*/, 1 /*rlbot.flat.MatchLength*/, 1, false)
      && verifier.VerifyField(tablePos, 6 /*MaxScore*/, 1 /*rlbot.flat.MaxScore*/, 1, false)
      && verifier.VerifyField(tablePos, 8 /*OvertimeOption*/, 1 /*rlbot.flat.OvertimeOption*/, 1, false)
      && verifier.VerifyField(tablePos, 10 /*SeriesLengthOption*/, 1 /*rlbot.flat.SeriesLengthOption*/, 1, false)
      && verifier.VerifyField(tablePos, 12 /*GameSpeedOption*/, 1 /*rlbot.flat.GameSpeedOption*/, 1, false)
      && verifier.VerifyField(tablePos, 14 /*BallMaxSpeedOption*/, 1 /*rlbot.flat.BallMaxSpeedOption*/, 1, false)
      && verifier.VerifyField(tablePos, 16 /*BallTypeOption*/, 1 /*rlbot.flat.BallTypeOption*/, 1, false)
      && verifier.VerifyField(tablePos, 18 /*BallWeightOption*/, 1 /*rlbot.flat.BallWeightOption*/, 1, false)
      && verifier.VerifyField(tablePos, 20 /*BallSizeOption*/, 1 /*rlbot.flat.BallSizeOption*/, 1, false)
      && verifier.VerifyField(tablePos, 22 /*BallBouncinessOption*/, 1 /*rlbot.flat.BallBouncinessOption*/, 1, false)
      && verifier.VerifyField(tablePos, 24 /*BoostOption*/, 1 /*rlbot.flat.BoostOption*/, 1, false)
      && verifier.VerifyField(tablePos, 26 /*RumbleOption*/, 1 /*rlbot.flat.RumbleOption*/, 1, false)
      && verifier.VerifyField(tablePos, 28 /*BoostStrengthOption*/, 1 /*rlbot.flat.BoostStrengthOption*/, 1, false)
      && verifier.VerifyField(tablePos, 30 /*GravityOption*/, 1 /*rlbot.flat.GravityOption*/, 1, false)
      && verifier.VerifyField(tablePos, 32 /*DemolishOption*/, 1 /*rlbot.flat.DemolishOption*/, 1, false)
      && verifier.VerifyField(tablePos, 34 /*RespawnTimeOption*/, 1 /*rlbot.flat.RespawnTimeOption*/, 1, false)
      && verifier.VerifyTableEnd(tablePos);
  }
}
public struct MatchSettings : IFlatbufferObject
{
  private Table __p;
  public ByteBuffer ByteBuffer { get { return __p.bb; } }
  public static void ValidateVersion() { FlatBufferConstants.FLATBUFFERS_23_5_26(); }
  public static MatchSettings GetRootAsMatchSettings(ByteBuffer _bb) { return GetRootAsMatchSettings(_bb, new MatchSettings()); }
  public static MatchSettings GetRootAsMatchSettings(ByteBuffer _bb, MatchSettings obj) { return (obj.__assign(_bb.GetInt(_bb.Position) + _bb.Position, _bb)); }
  public void __init(int _i, ByteBuffer _bb) { __p = new Table(_i, _bb); }
  public MatchSettings __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }

  public rlbot.flat.PlayerConfiguration? PlayerConfigurations(int j) { int o = __p.__offset(4); return o != 0 ? (rlbot.flat.PlayerConfiguration?)(new rlbot.flat.PlayerConfiguration()).__assign(__p.__indirect(__p.__vector(o) + j * 4), __p.bb) : null; }
  public int PlayerConfigurationsLength { get { int o = __p.__offset(4); return o != 0 ? __p.__vector_len(o) : 0; } }
  public rlbot.flat.GameMode GameMode { get { int o = __p.__offset(6); return o != 0 ? (rlbot.flat.GameMode)__p.bb.GetSbyte(o + __p.bb_pos) : rlbot.flat.GameMode.Soccer; } }
  public rlbot.flat.GameMap GameMap { get { int o = __p.__offset(8); return o != 0 ? (rlbot.flat.GameMap)__p.bb.GetSbyte(o + __p.bb_pos) : rlbot.flat.GameMap.DFHStadium; } }
  public bool SkipReplays { get { int o = __p.__offset(10); return o != 0 ? 0!=__p.bb.Get(o + __p.bb_pos) : (bool)false; } }
  public bool InstantStart { get { int o = __p.__offset(12); return o != 0 ? 0!=__p.bb.Get(o + __p.bb_pos) : (bool)false; } }
  public rlbot.flat.MutatorSettings? MutatorSettings { get { int o = __p.__offset(14); return o != 0 ? (rlbot.flat.MutatorSettings?)(new rlbot.flat.MutatorSettings()).__assign(__p.__indirect(o + __p.bb_pos), __p.bb) : null; } }
  public rlbot.flat.ExistingMatchBehavior ExistingMatchBehavior { get { int o = __p.__offset(16); return o != 0 ? (rlbot.flat.ExistingMatchBehavior)__p.bb.GetSbyte(o + __p.bb_pos) : rlbot.flat.ExistingMatchBehavior.Restart_If_Different; } }
  public bool EnableLockstep { get { int o = __p.__offset(18); return o != 0 ? 0!=__p.bb.Get(o + __p.bb_pos) : (bool)false; } }
  public bool EnableRendering { get { int o = __p.__offset(20); return o != 0 ? 0!=__p.bb.Get(o + __p.bb_pos) : (bool)false; } }
  public bool EnableStateSetting { get { int o = __p.__offset(22); return o != 0 ? 0!=__p.bb.Get(o + __p.bb_pos) : (bool)false; } }
  public bool AutoSaveReplay { get { int o = __p.__offset(24); return o != 0 ? 0!=__p.bb.Get(o + __p.bb_pos) : (bool)false; } }
  /// The name of a upk file, like UtopiaStadium_P, which should be loaded.
  /// If specified, this overrides gameMap. On Steam version of Rocket League,
  /// this can be used to load custom map files, but on Epic version it only
  /// works on the Psyonix maps. Still useful because maintaining the gameMap
  /// enum as new Psyonix maps are added is annoying.
  public string GameMapUpk { get { int o = __p.__offset(26); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetGameMapUpkBytes() { return __p.__vector_as_span<byte>(26, 1); }
#else
  public ArraySegment<byte>? GetGameMapUpkBytes() { return __p.__vector_as_arraysegment(26); }
#endif
  public byte[] GetGameMapUpkArray() { return __p.__vector_as_array<byte>(26); }

  public static Offset<rlbot.flat.MatchSettings> CreateMatchSettings(FlatBufferBuilder builder,
      VectorOffset playerConfigurationsOffset = default(VectorOffset),
      rlbot.flat.GameMode gameMode = rlbot.flat.GameMode.Soccer,
      rlbot.flat.GameMap gameMap = rlbot.flat.GameMap.DFHStadium,
      bool skipReplays = false,
      bool instantStart = false,
      Offset<rlbot.flat.MutatorSettings> mutatorSettingsOffset = default(Offset<rlbot.flat.MutatorSettings>),
      rlbot.flat.ExistingMatchBehavior existingMatchBehavior = rlbot.flat.ExistingMatchBehavior.Restart_If_Different,
      bool enableLockstep = false,
      bool enableRendering = false,
      bool enableStateSetting = false,
      bool autoSaveReplay = false,
      StringOffset gameMapUpkOffset = default(StringOffset)) {
    builder.StartTable(12);
    MatchSettings.AddGameMapUpk(builder, gameMapUpkOffset);
    MatchSettings.AddMutatorSettings(builder, mutatorSettingsOffset);
    MatchSettings.AddPlayerConfigurations(builder, playerConfigurationsOffset);
    MatchSettings.AddAutoSaveReplay(builder, autoSaveReplay);
    MatchSettings.AddEnableStateSetting(builder, enableStateSetting);
    MatchSettings.AddEnableRendering(builder, enableRendering);
    MatchSettings.AddEnableLockstep(builder, enableLockstep);
    MatchSettings.AddExistingMatchBehavior(builder, existingMatchBehavior);
    MatchSettings.AddInstantStart(builder, instantStart);
    MatchSettings.AddSkipReplays(builder, skipReplays);
    MatchSettings.AddGameMap(builder, gameMap);
    MatchSettings.AddGameMode(builder, gameMode);
    return MatchSettings.EndMatchSettings(builder);
  }

  public static void StartMatchSettings(FlatBufferBuilder builder) { builder.StartTable(12); }
  public static void AddPlayerConfigurations(FlatBufferBuilder builder, VectorOffset playerConfigurationsOffset) { builder.AddOffset(0, playerConfigurationsOffset.Value, 0); }
  public static VectorOffset CreatePlayerConfigurationsVector(FlatBufferBuilder builder, Offset<rlbot.flat.PlayerConfiguration>[] data) { builder.StartVector(4, data.Length, 4); for (int i = data.Length - 1; i >= 0; i--) builder.AddOffset(data[i].Value); return builder.EndVector(); }
  public static VectorOffset CreatePlayerConfigurationsVectorBlock(FlatBufferBuilder builder, Offset<rlbot.flat.PlayerConfiguration>[] data) { builder.StartVector(4, data.Length, 4); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreatePlayerConfigurationsVectorBlock(FlatBufferBuilder builder, ArraySegment<Offset<rlbot.flat.PlayerConfiguration>> data) { builder.StartVector(4, data.Count, 4); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreatePlayerConfigurationsVectorBlock(FlatBufferBuilder builder, IntPtr dataPtr, int sizeInBytes) { builder.StartVector(1, sizeInBytes, 1); builder.Add<Offset<rlbot.flat.PlayerConfiguration>>(dataPtr, sizeInBytes); return builder.EndVector(); }
  public static void StartPlayerConfigurationsVector(FlatBufferBuilder builder, int numElems) { builder.StartVector(4, numElems, 4); }
  public static void AddGameMode(FlatBufferBuilder builder, rlbot.flat.GameMode gameMode) { builder.AddSbyte(1, (sbyte)gameMode, 0); }
  public static void AddGameMap(FlatBufferBuilder builder, rlbot.flat.GameMap gameMap) { builder.AddSbyte(2, (sbyte)gameMap, 0); }
  public static void AddSkipReplays(FlatBufferBuilder builder, bool skipReplays) { builder.AddBool(3, skipReplays, false); }
  public static void AddInstantStart(FlatBufferBuilder builder, bool instantStart) { builder.AddBool(4, instantStart, false); }
  public static void AddMutatorSettings(FlatBufferBuilder builder, Offset<rlbot.flat.MutatorSettings> mutatorSettingsOffset) { builder.AddOffset(5, mutatorSettingsOffset.Value, 0); }
  public static void AddExistingMatchBehavior(FlatBufferBuilder builder, rlbot.flat.ExistingMatchBehavior existingMatchBehavior) { builder.AddSbyte(6, (sbyte)existingMatchBehavior, 0); }
  public static void AddEnableLockstep(FlatBufferBuilder builder, bool enableLockstep) { builder.AddBool(7, enableLockstep, false); }
  public static void AddEnableRendering(FlatBufferBuilder builder, bool enableRendering) { builder.AddBool(8, enableRendering, false); }
  public static void AddEnableStateSetting(FlatBufferBuilder builder, bool enableStateSetting) { builder.AddBool(9, enableStateSetting, false); }
  public static void AddAutoSaveReplay(FlatBufferBuilder builder, bool autoSaveReplay) { builder.AddBool(10, autoSaveReplay, false); }
  public static void AddGameMapUpk(FlatBufferBuilder builder, StringOffset gameMapUpkOffset) { builder.AddOffset(11, gameMapUpkOffset.Value, 0); }
  public static Offset<rlbot.flat.MatchSettings> EndMatchSettings(FlatBufferBuilder builder) {
    int o = builder.EndTable();
    return new Offset<rlbot.flat.MatchSettings>(o);
  }
}


static public class MatchSettingsVerify
{
  static public bool Verify(Google.FlatBuffers.Verifier verifier, uint tablePos)
  {
    return verifier.VerifyTableStart(tablePos)
      && verifier.VerifyVectorOfTables(tablePos, 4 /*PlayerConfigurations*/, rlbot.flat.PlayerConfigurationVerify.Verify, false)
      && verifier.VerifyField(tablePos, 6 /*GameMode*/, 1 /*rlbot.flat.GameMode*/, 1, false)
      && verifier.VerifyField(tablePos, 8 /*GameMap*/, 1 /*rlbot.flat.GameMap*/, 1, false)
      && verifier.VerifyField(tablePos, 10 /*SkipReplays*/, 1 /*bool*/, 1, false)
      && verifier.VerifyField(tablePos, 12 /*InstantStart*/, 1 /*bool*/, 1, false)
      && verifier.VerifyTable(tablePos, 14 /*MutatorSettings*/, rlbot.flat.MutatorSettingsVerify.Verify, false)
      && verifier.VerifyField(tablePos, 16 /*ExistingMatchBehavior*/, 1 /*rlbot.flat.ExistingMatchBehavior*/, 1, false)
      && verifier.VerifyField(tablePos, 18 /*EnableLockstep*/, 1 /*bool*/, 1, false)
      && verifier.VerifyField(tablePos, 20 /*EnableRendering*/, 1 /*bool*/, 1, false)
      && verifier.VerifyField(tablePos, 22 /*EnableStateSetting*/, 1 /*bool*/, 1, false)
      && verifier.VerifyField(tablePos, 24 /*AutoSaveReplay*/, 1 /*bool*/, 1, false)
      && verifier.VerifyString(tablePos, 26 /*GameMapUpk*/, false)
      && verifier.VerifyTableEnd(tablePos);
  }
}
public struct QuickChatMessages : IFlatbufferObject
{
  private Table __p;
  public ByteBuffer ByteBuffer { get { return __p.bb; } }
  public static void ValidateVersion() { FlatBufferConstants.FLATBUFFERS_23_5_26(); }
  public static QuickChatMessages GetRootAsQuickChatMessages(ByteBuffer _bb) { return GetRootAsQuickChatMessages(_bb, new QuickChatMessages()); }
  public static QuickChatMessages GetRootAsQuickChatMessages(ByteBuffer _bb, QuickChatMessages obj) { return (obj.__assign(_bb.GetInt(_bb.Position) + _bb.Position, _bb)); }
  public void __init(int _i, ByteBuffer _bb) { __p = new Table(_i, _bb); }
  public QuickChatMessages __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }

  public rlbot.flat.QuickChat? Messages(int j) { int o = __p.__offset(4); return o != 0 ? (rlbot.flat.QuickChat?)(new rlbot.flat.QuickChat()).__assign(__p.__indirect(__p.__vector(o) + j * 4), __p.bb) : null; }
  public int MessagesLength { get { int o = __p.__offset(4); return o != 0 ? __p.__vector_len(o) : 0; } }

  public static Offset<rlbot.flat.QuickChatMessages> CreateQuickChatMessages(FlatBufferBuilder builder,
      VectorOffset messagesOffset = default(VectorOffset)) {
    builder.StartTable(1);
    QuickChatMessages.AddMessages(builder, messagesOffset);
    return QuickChatMessages.EndQuickChatMessages(builder);
  }

  public static void StartQuickChatMessages(FlatBufferBuilder builder) { builder.StartTable(1); }
  public static void AddMessages(FlatBufferBuilder builder, VectorOffset messagesOffset) { builder.AddOffset(0, messagesOffset.Value, 0); }
  public static VectorOffset CreateMessagesVector(FlatBufferBuilder builder, Offset<rlbot.flat.QuickChat>[] data) { builder.StartVector(4, data.Length, 4); for (int i = data.Length - 1; i >= 0; i--) builder.AddOffset(data[i].Value); return builder.EndVector(); }
  public static VectorOffset CreateMessagesVectorBlock(FlatBufferBuilder builder, Offset<rlbot.flat.QuickChat>[] data) { builder.StartVector(4, data.Length, 4); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreateMessagesVectorBlock(FlatBufferBuilder builder, ArraySegment<Offset<rlbot.flat.QuickChat>> data) { builder.StartVector(4, data.Count, 4); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreateMessagesVectorBlock(FlatBufferBuilder builder, IntPtr dataPtr, int sizeInBytes) { builder.StartVector(1, sizeInBytes, 1); builder.Add<Offset<rlbot.flat.QuickChat>>(dataPtr, sizeInBytes); return builder.EndVector(); }
  public static void StartMessagesVector(FlatBufferBuilder builder, int numElems) { builder.StartVector(4, numElems, 4); }
  public static Offset<rlbot.flat.QuickChatMessages> EndQuickChatMessages(FlatBufferBuilder builder) {
    int o = builder.EndTable();
    return new Offset<rlbot.flat.QuickChatMessages>(o);
  }
}


static public class QuickChatMessagesVerify
{
  static public bool Verify(Google.FlatBuffers.Verifier verifier, uint tablePos)
  {
    return verifier.VerifyTableStart(tablePos)
      && verifier.VerifyVectorOfTables(tablePos, 4 /*Messages*/, rlbot.flat.QuickChatVerify.Verify, false)
      && verifier.VerifyTableEnd(tablePos);
  }
}
/// Sent when connecting to RLBot to indicate what type of messages are desired.
/// This could be sent by a bot, or a bot manager governing several bots, an
/// overlay, or any other utility that connects to the RLBot process.
public struct ReadyMessage : IFlatbufferObject
{
  private Table __p;
  public ByteBuffer ByteBuffer { get { return __p.bb; } }
  public static void ValidateVersion() { FlatBufferConstants.FLATBUFFERS_23_5_26(); }
  public static ReadyMessage GetRootAsReadyMessage(ByteBuffer _bb) { return GetRootAsReadyMessage(_bb, new ReadyMessage()); }
  public static ReadyMessage GetRootAsReadyMessage(ByteBuffer _bb, ReadyMessage obj) { return (obj.__assign(_bb.GetInt(_bb.Position) + _bb.Position, _bb)); }
  public void __init(int _i, ByteBuffer _bb) { __p = new Table(_i, _bb); }
  public ReadyMessage __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }

  public bool WantsBallPredictions { get { int o = __p.__offset(4); return o != 0 ? 0!=__p.bb.Get(o + __p.bb_pos) : (bool)false; } }
  public bool WantsQuickChat { get { int o = __p.__offset(6); return o != 0 ? 0!=__p.bb.Get(o + __p.bb_pos) : (bool)false; } }
  public bool WantsGameMessages { get { int o = __p.__offset(8); return o != 0 ? 0!=__p.bb.Get(o + __p.bb_pos) : (bool)false; } }

  public static Offset<rlbot.flat.ReadyMessage> CreateReadyMessage(FlatBufferBuilder builder,
      bool wantsBallPredictions = false,
      bool wantsQuickChat = false,
      bool wantsGameMessages = false) {
    builder.StartTable(3);
    ReadyMessage.AddWantsGameMessages(builder, wantsGameMessages);
    ReadyMessage.AddWantsQuickChat(builder, wantsQuickChat);
    ReadyMessage.AddWantsBallPredictions(builder, wantsBallPredictions);
    return ReadyMessage.EndReadyMessage(builder);
  }

  public static void StartReadyMessage(FlatBufferBuilder builder) { builder.StartTable(3); }
  public static void AddWantsBallPredictions(FlatBufferBuilder builder, bool wantsBallPredictions) { builder.AddBool(0, wantsBallPredictions, false); }
  public static void AddWantsQuickChat(FlatBufferBuilder builder, bool wantsQuickChat) { builder.AddBool(1, wantsQuickChat, false); }
  public static void AddWantsGameMessages(FlatBufferBuilder builder, bool wantsGameMessages) { builder.AddBool(2, wantsGameMessages, false); }
  public static Offset<rlbot.flat.ReadyMessage> EndReadyMessage(FlatBufferBuilder builder) {
    int o = builder.EndTable();
    return new Offset<rlbot.flat.ReadyMessage>(o);
  }
}


static public class ReadyMessageVerify
{
  static public bool Verify(Google.FlatBuffers.Verifier verifier, uint tablePos)
  {
    return verifier.VerifyTableStart(tablePos)
      && verifier.VerifyField(tablePos, 4 /*WantsBallPredictions*/, 1 /*bool*/, 1, false)
      && verifier.VerifyField(tablePos, 6 /*WantsQuickChat*/, 1 /*bool*/, 1, false)
      && verifier.VerifyField(tablePos, 8 /*WantsGameMessages*/, 1 /*bool*/, 1, false)
      && verifier.VerifyTableEnd(tablePos);
  }
}
/// Notification that a player triggers some in-game event, such as:
///		Win, Loss, TimePlayed;
///		Shot, Assist, Center, Clear, PoolShot;
///		Goal, AerialGoal, BicycleGoal, BulletGoal, BackwardsGoal, LongGoal, OvertimeGoal, TurtleGoal;
///		AerialHit, BicycleHit, BulletHit, JuggleHit, FirstTouch, BallHit;
///		Save, EpicSave, FreezeSave;
///		HatTrick, Savior, Playmaker, MVP;
///		FastestGoal, SlowestGoal, FurthestGoal, OwnGoal;
///		MostBallTouches, FewestBallTouches, MostBoostPickups, FewestBoostPickups, BoostPickups;
///		CarTouches, Demolition, Demolish;
///		LowFive, HighFive;
public struct PlayerStatEvent : IFlatbufferObject
{
  private Table __p;
  public ByteBuffer ByteBuffer { get { return __p.bb; } }
  public static void ValidateVersion() { FlatBufferConstants.FLATBUFFERS_23_5_26(); }
  public static PlayerStatEvent GetRootAsPlayerStatEvent(ByteBuffer _bb) { return GetRootAsPlayerStatEvent(_bb, new PlayerStatEvent()); }
  public static PlayerStatEvent GetRootAsPlayerStatEvent(ByteBuffer _bb, PlayerStatEvent obj) { return (obj.__assign(_bb.GetInt(_bb.Position) + _bb.Position, _bb)); }
  public void __init(int _i, ByteBuffer _bb) { __p = new Table(_i, _bb); }
  public PlayerStatEvent __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }

  /// index of the player associated with the event
  public int PlayerIndex { get { int o = __p.__offset(4); return o != 0 ? __p.bb.GetInt(o + __p.bb_pos) : (int)0; } }
  /// Event type
  public string StatType { get { int o = __p.__offset(6); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetStatTypeBytes() { return __p.__vector_as_span<byte>(6, 1); }
#else
  public ArraySegment<byte>? GetStatTypeBytes() { return __p.__vector_as_arraysegment(6); }
#endif
  public byte[] GetStatTypeArray() { return __p.__vector_as_array<byte>(6); }

  public static Offset<rlbot.flat.PlayerStatEvent> CreatePlayerStatEvent(FlatBufferBuilder builder,
      int playerIndex = 0,
      StringOffset statTypeOffset = default(StringOffset)) {
    builder.StartTable(2);
    PlayerStatEvent.AddStatType(builder, statTypeOffset);
    PlayerStatEvent.AddPlayerIndex(builder, playerIndex);
    return PlayerStatEvent.EndPlayerStatEvent(builder);
  }

  public static void StartPlayerStatEvent(FlatBufferBuilder builder) { builder.StartTable(2); }
  public static void AddPlayerIndex(FlatBufferBuilder builder, int playerIndex) { builder.AddInt(0, playerIndex, 0); }
  public static void AddStatType(FlatBufferBuilder builder, StringOffset statTypeOffset) { builder.AddOffset(1, statTypeOffset.Value, 0); }
  public static Offset<rlbot.flat.PlayerStatEvent> EndPlayerStatEvent(FlatBufferBuilder builder) {
    int o = builder.EndTable();
    return new Offset<rlbot.flat.PlayerStatEvent>(o);
  }
}


static public class PlayerStatEventVerify
{
  static public bool Verify(Google.FlatBuffers.Verifier verifier, uint tablePos)
  {
    return verifier.VerifyTableStart(tablePos)
      && verifier.VerifyField(tablePos, 4 /*PlayerIndex*/, 4 /*int*/, 4, false)
      && verifier.VerifyString(tablePos, 6 /*StatType*/, false)
      && verifier.VerifyTableEnd(tablePos);
  }
}
/// Notification when the local player is spectating another player.
public struct PlayerSpectate : IFlatbufferObject
{
  private Table __p;
  public ByteBuffer ByteBuffer { get { return __p.bb; } }
  public static void ValidateVersion() { FlatBufferConstants.FLATBUFFERS_23_5_26(); }
  public static PlayerSpectate GetRootAsPlayerSpectate(ByteBuffer _bb) { return GetRootAsPlayerSpectate(_bb, new PlayerSpectate()); }
  public static PlayerSpectate GetRootAsPlayerSpectate(ByteBuffer _bb, PlayerSpectate obj) { return (obj.__assign(_bb.GetInt(_bb.Position) + _bb.Position, _bb)); }
  public void __init(int _i, ByteBuffer _bb) { __p = new Table(_i, _bb); }
  public PlayerSpectate __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }

  /// index of the player that is being spectated. Will be -1 if not spectating anyone.
  public int PlayerIndex { get { int o = __p.__offset(4); return o != 0 ? __p.bb.GetInt(o + __p.bb_pos) : (int)0; } }

  public static Offset<rlbot.flat.PlayerSpectate> CreatePlayerSpectate(FlatBufferBuilder builder,
      int playerIndex = 0) {
    builder.StartTable(1);
    PlayerSpectate.AddPlayerIndex(builder, playerIndex);
    return PlayerSpectate.EndPlayerSpectate(builder);
  }

  public static void StartPlayerSpectate(FlatBufferBuilder builder) { builder.StartTable(1); }
  public static void AddPlayerIndex(FlatBufferBuilder builder, int playerIndex) { builder.AddInt(0, playerIndex, 0); }
  public static Offset<rlbot.flat.PlayerSpectate> EndPlayerSpectate(FlatBufferBuilder builder) {
    int o = builder.EndTable();
    return new Offset<rlbot.flat.PlayerSpectate>(o);
  }
}


static public class PlayerSpectateVerify
{
  static public bool Verify(Google.FlatBuffers.Verifier verifier, uint tablePos)
  {
    return verifier.VerifyTableStart(tablePos)
      && verifier.VerifyField(tablePos, 4 /*PlayerIndex*/, 4 /*int*/, 4, false)
      && verifier.VerifyTableEnd(tablePos);
  }
}
/// Rocket League is notifying us that some player has moved their controller. This is an *output*
public struct PlayerInputChange : IFlatbufferObject
{
  private Table __p;
  public ByteBuffer ByteBuffer { get { return __p.bb; } }
  public static void ValidateVersion() { FlatBufferConstants.FLATBUFFERS_23_5_26(); }
  public static PlayerInputChange GetRootAsPlayerInputChange(ByteBuffer _bb) { return GetRootAsPlayerInputChange(_bb, new PlayerInputChange()); }
  public static PlayerInputChange GetRootAsPlayerInputChange(ByteBuffer _bb, PlayerInputChange obj) { return (obj.__assign(_bb.GetInt(_bb.Position) + _bb.Position, _bb)); }
  public void __init(int _i, ByteBuffer _bb) { __p = new Table(_i, _bb); }
  public PlayerInputChange __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }

  public int PlayerIndex { get { int o = __p.__offset(4); return o != 0 ? __p.bb.GetInt(o + __p.bb_pos) : (int)0; } }
  public rlbot.flat.ControllerState? ControllerState { get { int o = __p.__offset(6); return o != 0 ? (rlbot.flat.ControllerState?)(new rlbot.flat.ControllerState()).__assign(__p.__indirect(o + __p.bb_pos), __p.bb) : null; } }
  public float DodgeForward { get { int o = __p.__offset(8); return o != 0 ? __p.bb.GetFloat(o + __p.bb_pos) : (float)0.0f; } }
  public float DodgeRight { get { int o = __p.__offset(10); return o != 0 ? __p.bb.GetFloat(o + __p.bb_pos) : (float)0.0f; } }

  public static Offset<rlbot.flat.PlayerInputChange> CreatePlayerInputChange(FlatBufferBuilder builder,
      int playerIndex = 0,
      Offset<rlbot.flat.ControllerState> controllerStateOffset = default(Offset<rlbot.flat.ControllerState>),
      float dodgeForward = 0.0f,
      float dodgeRight = 0.0f) {
    builder.StartTable(4);
    PlayerInputChange.AddDodgeRight(builder, dodgeRight);
    PlayerInputChange.AddDodgeForward(builder, dodgeForward);
    PlayerInputChange.AddControllerState(builder, controllerStateOffset);
    PlayerInputChange.AddPlayerIndex(builder, playerIndex);
    return PlayerInputChange.EndPlayerInputChange(builder);
  }

  public static void StartPlayerInputChange(FlatBufferBuilder builder) { builder.StartTable(4); }
  public static void AddPlayerIndex(FlatBufferBuilder builder, int playerIndex) { builder.AddInt(0, playerIndex, 0); }
  public static void AddControllerState(FlatBufferBuilder builder, Offset<rlbot.flat.ControllerState> controllerStateOffset) { builder.AddOffset(1, controllerStateOffset.Value, 0); }
  public static void AddDodgeForward(FlatBufferBuilder builder, float dodgeForward) { builder.AddFloat(2, dodgeForward, 0.0f); }
  public static void AddDodgeRight(FlatBufferBuilder builder, float dodgeRight) { builder.AddFloat(3, dodgeRight, 0.0f); }
  public static Offset<rlbot.flat.PlayerInputChange> EndPlayerInputChange(FlatBufferBuilder builder) {
    int o = builder.EndTable();
    return new Offset<rlbot.flat.PlayerInputChange>(o);
  }
}


static public class PlayerInputChangeVerify
{
  static public bool Verify(Google.FlatBuffers.Verifier verifier, uint tablePos)
  {
    return verifier.VerifyTableStart(tablePos)
      && verifier.VerifyField(tablePos, 4 /*PlayerIndex*/, 4 /*int*/, 4, false)
      && verifier.VerifyTable(tablePos, 6 /*ControllerState*/, rlbot.flat.ControllerStateVerify.Verify, false)
      && verifier.VerifyField(tablePos, 8 /*DodgeForward*/, 4 /*float*/, 4, false)
      && verifier.VerifyField(tablePos, 10 /*DodgeRight*/, 4 /*float*/, 4, false)
      && verifier.VerifyTableEnd(tablePos);
  }
}
public struct GameMessageWrapper : IFlatbufferObject
{
  private Table __p;
  public ByteBuffer ByteBuffer { get { return __p.bb; } }
  public static void ValidateVersion() { FlatBufferConstants.FLATBUFFERS_23_5_26(); }
  public static GameMessageWrapper GetRootAsGameMessageWrapper(ByteBuffer _bb) { return GetRootAsGameMessageWrapper(_bb, new GameMessageWrapper()); }
  public static GameMessageWrapper GetRootAsGameMessageWrapper(ByteBuffer _bb, GameMessageWrapper obj) { return (obj.__assign(_bb.GetInt(_bb.Position) + _bb.Position, _bb)); }
  public void __init(int _i, ByteBuffer _bb) { __p = new Table(_i, _bb); }
  public GameMessageWrapper __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }

  public rlbot.flat.GameMessage MessageType { get { int o = __p.__offset(4); return o != 0 ? (rlbot.flat.GameMessage)__p.bb.Get(o + __p.bb_pos) : rlbot.flat.GameMessage.NONE; } }
  public TTable? Message<TTable>() where TTable : struct, IFlatbufferObject { int o = __p.__offset(6); return o != 0 ? (TTable?)__p.__union<TTable>(o + __p.bb_pos) : null; }
  public rlbot.flat.PlayerStatEvent MessageAsPlayerStatEvent() { return Message<rlbot.flat.PlayerStatEvent>().Value; }
  public rlbot.flat.PlayerSpectate MessageAsPlayerSpectate() { return Message<rlbot.flat.PlayerSpectate>().Value; }
  public rlbot.flat.PlayerInputChange MessageAsPlayerInputChange() { return Message<rlbot.flat.PlayerInputChange>().Value; }

  public static Offset<rlbot.flat.GameMessageWrapper> CreateGameMessageWrapper(FlatBufferBuilder builder,
      rlbot.flat.GameMessage Message_type = rlbot.flat.GameMessage.NONE,
      int MessageOffset = 0) {
    builder.StartTable(2);
    GameMessageWrapper.AddMessage(builder, MessageOffset);
    GameMessageWrapper.AddMessageType(builder, Message_type);
    return GameMessageWrapper.EndGameMessageWrapper(builder);
  }

  public static void StartGameMessageWrapper(FlatBufferBuilder builder) { builder.StartTable(2); }
  public static void AddMessageType(FlatBufferBuilder builder, rlbot.flat.GameMessage messageType) { builder.AddByte(0, (byte)messageType, 0); }
  public static void AddMessage(FlatBufferBuilder builder, int messageOffset) { builder.AddOffset(1, messageOffset, 0); }
  public static Offset<rlbot.flat.GameMessageWrapper> EndGameMessageWrapper(FlatBufferBuilder builder) {
    int o = builder.EndTable();
    return new Offset<rlbot.flat.GameMessageWrapper>(o);
  }
}


static public class GameMessageWrapperVerify
{
  static public bool Verify(Google.FlatBuffers.Verifier verifier, uint tablePos)
  {
    return verifier.VerifyTableStart(tablePos)
      && verifier.VerifyField(tablePos, 4 /*MessageType*/, 1 /*rlbot.flat.GameMessage*/, 1, false)
      && verifier.VerifyUnion(tablePos, 4, 6 /*Message*/, rlbot.flat.GameMessageVerify.Verify, false)
      && verifier.VerifyTableEnd(tablePos);
  }
}
/// We have some very small messages that are only a few bytes but potentially sent at high frequency.
/// Bundle them into a packet to reduce the overhead of sending data over TCP.
public struct MessagePacket : IFlatbufferObject
{
  private Table __p;
  public ByteBuffer ByteBuffer { get { return __p.bb; } }
  public static void ValidateVersion() { FlatBufferConstants.FLATBUFFERS_23_5_26(); }
  public static MessagePacket GetRootAsMessagePacket(ByteBuffer _bb) { return GetRootAsMessagePacket(_bb, new MessagePacket()); }
  public static MessagePacket GetRootAsMessagePacket(ByteBuffer _bb, MessagePacket obj) { return (obj.__assign(_bb.GetInt(_bb.Position) + _bb.Position, _bb)); }
  public void __init(int _i, ByteBuffer _bb) { __p = new Table(_i, _bb); }
  public MessagePacket __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }

  public rlbot.flat.GameMessageWrapper? Messages(int j) { int o = __p.__offset(4); return o != 0 ? (rlbot.flat.GameMessageWrapper?)(new rlbot.flat.GameMessageWrapper()).__assign(__p.__indirect(__p.__vector(o) + j * 4), __p.bb) : null; }
  public int MessagesLength { get { int o = __p.__offset(4); return o != 0 ? __p.__vector_len(o) : 0; } }
  public float GameSeconds { get { int o = __p.__offset(6); return o != 0 ? __p.bb.GetFloat(o + __p.bb_pos) : (float)0.0f; } }
  public int FrameNum { get { int o = __p.__offset(8); return o != 0 ? __p.bb.GetInt(o + __p.bb_pos) : (int)0; } }

  public static Offset<rlbot.flat.MessagePacket> CreateMessagePacket(FlatBufferBuilder builder,
      VectorOffset messagesOffset = default(VectorOffset),
      float gameSeconds = 0.0f,
      int frameNum = 0) {
    builder.StartTable(3);
    MessagePacket.AddFrameNum(builder, frameNum);
    MessagePacket.AddGameSeconds(builder, gameSeconds);
    MessagePacket.AddMessages(builder, messagesOffset);
    return MessagePacket.EndMessagePacket(builder);
  }

  public static void StartMessagePacket(FlatBufferBuilder builder) { builder.StartTable(3); }
  public static void AddMessages(FlatBufferBuilder builder, VectorOffset messagesOffset) { builder.AddOffset(0, messagesOffset.Value, 0); }
  public static VectorOffset CreateMessagesVector(FlatBufferBuilder builder, Offset<rlbot.flat.GameMessageWrapper>[] data) { builder.StartVector(4, data.Length, 4); for (int i = data.Length - 1; i >= 0; i--) builder.AddOffset(data[i].Value); return builder.EndVector(); }
  public static VectorOffset CreateMessagesVectorBlock(FlatBufferBuilder builder, Offset<rlbot.flat.GameMessageWrapper>[] data) { builder.StartVector(4, data.Length, 4); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreateMessagesVectorBlock(FlatBufferBuilder builder, ArraySegment<Offset<rlbot.flat.GameMessageWrapper>> data) { builder.StartVector(4, data.Count, 4); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreateMessagesVectorBlock(FlatBufferBuilder builder, IntPtr dataPtr, int sizeInBytes) { builder.StartVector(1, sizeInBytes, 1); builder.Add<Offset<rlbot.flat.GameMessageWrapper>>(dataPtr, sizeInBytes); return builder.EndVector(); }
  public static void StartMessagesVector(FlatBufferBuilder builder, int numElems) { builder.StartVector(4, numElems, 4); }
  public static void AddGameSeconds(FlatBufferBuilder builder, float gameSeconds) { builder.AddFloat(1, gameSeconds, 0.0f); }
  public static void AddFrameNum(FlatBufferBuilder builder, int frameNum) { builder.AddInt(2, frameNum, 0); }
  public static Offset<rlbot.flat.MessagePacket> EndMessagePacket(FlatBufferBuilder builder) {
    int o = builder.EndTable();
    return new Offset<rlbot.flat.MessagePacket>(o);
  }
}


static public class MessagePacketVerify
{
  static public bool Verify(Google.FlatBuffers.Verifier verifier, uint tablePos)
  {
    return verifier.VerifyTableStart(tablePos)
      && verifier.VerifyVectorOfTables(tablePos, 4 /*Messages*/, rlbot.flat.GameMessageWrapperVerify.Verify, false)
      && verifier.VerifyField(tablePos, 6 /*GameSeconds*/, 4 /*float*/, 4, false)
      && verifier.VerifyField(tablePos, 8 /*FrameNum*/, 4 /*int*/, 4, false)
      && verifier.VerifyTableEnd(tablePos);
  }
}

}
